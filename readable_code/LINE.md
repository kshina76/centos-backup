# LINE株式会社のコードの可読性の講座
- https://speakerdeck.com/munetoshi
## 第1章 導入
- リータブルコードの基本
  - 明示的な変数名: `flag`より`isVisible`
  - シンプル: `!(!isA || !isB) && isB`より`isA && isB`
  - 独立性: 責務と依存の設計
  - 構造: フォーマット、メンバ、相互作用、抽象化レイヤー
- なぜ読みやすいコードを書くのか
  - 自分の5分間の手間は他の人の1時間の手間を削減する
    - コメントを書く、テストを書く、レファクタリングする、...
### ボーイスカウトルール
- 追加するもの
  - コメント、テスト
- 取り除くもの
  - 不必要な依存関係、不必要なメンバ、不必要な状態
- リネームするもの
  - type、関数、変数
- 分割するもの
  - 大きいtype、大きい関数、ネスト、call sequence
- 構造
  - 依存関係、抽象化レイヤー、typeヒエラルキー
### if文をストラテジーパターンで置き換える
- https://gist.github.com/fujimisakari/5797dfb18f4fc350e206eced83474d2e
### YAGNI
- 機能は必要になった時だけ実装しろ
- 「将来使いそうだから実装する」は90%が使われない
- 構造をシンプルに保つ -> 将来の予想できない変更に準備するため
- 例(削除するべきもの)
  - 使用していない「type、関数、変数」
  - 一つしか実装されていない抽象メソッドや抽象クラス
  - 一箇所からしか使われていないutilクラスやutilメソッド
  - コメントアウトされたコード
### KISS
- シンプルにしろ
- 例
  - フレームワークやライブラリをフル活用する
  - 標準の関数を駆使する
### 単一責務の法則
- あとで例をまとめる
### 早期の最適化
- 早期の最適化の97%が諸悪の根源
- 最適化によってコードが読みにくくなるなら、それはダメな最適化
- 最適化によってコードが読みやすくなるなら、それは良い最適化
- 早期の最適化のダメな例
  - ミュータブルなインスタンスの再利用
  - 遅延評価(Lazy Initialization)
    - メンバフィールドやメンバフィールドが参照するオブジェクトの生成を、インスタンスが実際に必要になるまで延期すること
    - これにより、クラスのコンストラクタにおいて、フィールドの値を計算したり参照されるオブジェクトを生成したりする必要がなくなる
    - クラスやインスタンスの循環初期化を防止することにもつながる
  - キャッシュ
  - Inline Extraction
  - Instance Pool(オブジェクトプール)
    - インスタンスを大量に作成するようなアプリケーションの場合に、最初からインスタンスを生成しておくといった方法
    - http://www.lancarse.co.jp/blog/?p=3231
- コンパイラは自分より賢いので、作り終わってからボトルネックになっているところをプロファイラなどを見ながら最適化するようにする

<br></br>

## 第2章 ネーミング
- コードの命名をしてくれるサイト
  - https://codic.jp
### 正しい英語の文法
