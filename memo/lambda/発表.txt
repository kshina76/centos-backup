・list_launch_pathを取得するのにポートフォリオのアクセス権を与える必要があった。動作を確認するためにservice catalogのfull accessを与えたが取得できなかったので、結構ハマった。

・lambdaのコスト削減
yamlを読み込む外部モジュールを使っていることで、lambdaを二つに分けてしまうとコードの容量がおおきくなってしまうため、lambdaを一つにしてコストを削減する。

・トリガーによってeventに格納されるときにeventによってエラーが発生してしまう
lambdaを一つにするためにトリガーをs3とcwlの二つにして、eventの種類によって条件分岐しようと思ったが、cwlはeventがbase64で暗号化される事で、eventにアクセスするインデックスがs3とcwlで違うため、そこで必ずエラーが発生してしまう。なので、try-exceptで条件分岐をするという力技？？で行った。やり方がいいのかといわれると微妙。

・なぜかアカウントの作成が成功しても失敗してもcwlがトリガーになってしまう問題
cwlにアカウントの作成は成功でも失敗でもCREATEDと表示されてしまうので、cwlのトリガー起動したときにlambdaの中でsearch_provisioned_productでアカウントの状態を調べて、成功か失敗かを条件分岐する。

・アカウントを作成しようとしたときに同一の名前のアカウントが作成されようとすると、botocoreのclienterrorが発声して三回lambdaがリトライする。
try-exceptしてslack通知してreturnすればlambdaのリトライによってslack通知が複数されることを防ぐ

・アカウント作成の時に引数の整合性チェックはされないのでbotocoreのclienterrorが発生しない。
このことから、引数の間違えによるアカウント作成エラーはtry-exceptで処理できないので、アカウント作成をスタートした後に、search_provisioned_productでアカウントのステータスを調べて、ERRORになっていたらアカウント作成失敗のslack通知をする。さらにこの場合はcontrol towerのcloudwatchlogsにアカウントの状態がロギングされないためトリガーされない。なので、トリガー前にs3のeventのときのlambdaの処理でもsearch_provisioned_productでのチェックを行う。

・yamlをアカウント毎に配列で記述して、プログラムの方でfor文でyamlのインデックスを回すことで複数のアカウントを一回のコミットで作成できるようにした。

・アカウントの作成を始めたばかりだとERRORでもすべて最初はUNDER_CHANGEから始まるので、sleepを使って15秒待つことにした。

・cloudwatchlogsのeventでログを受け取るとbase64のエンコードがされる。そこからデコードしてjsonにdumpしても、一部分が文字列になってしまっているので、さらにその部分を抜き出してからjsonに変換して対応した。

〜memo〜
・search_provisioed_productの返り値を見て、成功と失敗の分岐の実装をする。そこでslack通知。
try-execptとsys.exit()を使えば、lambdaリトライ回数を変えなくても大丈夫と思ったけど、sysで強制的に終了してしまうとlambdaのリトライが走ってしまうのでreturnで値を返すことで処理の途中で切り上げることができる。

・参考になる本番運用を見据えたloggingなど
https://recipe.kc-cloud.jp/archives/9968

・boto3のエラーハンドリング
http://benzenetarou.hatenablog.com/entry/boto3_error

〜わかったこと〜
・try-execptはエラーが出ても処理を終わらせないでslack通知をしたいときなどに使える。

・boto3のエラーハンドリングはbotocoreのclienterrorを使わないとできない。
http://benzenetarou.hatenablog.com/entry/boto3_error

・accountの作成状況をcloudwatchlogsから取得する部分(P83)


