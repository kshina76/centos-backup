# アプリケーションアーキテクチャ
- アプリケーションアーキテクチャを実践に取り入れるときに考えることをまとめた

## アプリケーションアーキテクチャまとめ

- 記事まとめる
https://times.hrbrain.co.jp/entry/good_arch_for_team_change
https://gibachansblog.hatenablog.jp/entry/2020/02/29/222535
https://scrapbox.io/kawasima/レイヤードアーキテクチャ

- レイヤー間でのデータの受け渡しはdtoを使う
https://github.com/little-hands/ddd-q-and-a/issues/81

- DDDのレイヤードアーキテクチャ
    - 「プレゼンテーション層->ユースケース層->domain層(infra層)->domain層」という順に処理
        - domain層(infra層)というのは、domain層のinterfaceを介して間接的にinfra層にアクセスしているということ。DIPによってこのようになっている。
        - ユースケース層はdomain層(infra層)にアクセスして受け取ったデータをdomain層に流して、domain層がビジネスロジックを実行するという手順。
        - 単純なCRUDアプリだと、ユースケース層がdomain層(infra層)にアクセスしてデータを受け取った時点で、ユースケースを満たしてしまうため、domain層のビジネスロジックが存在しないいわゆるドメインモデル貧血症になる。
        - ユースケース層には加えて、プッシュ通知といったdomain層のビジネスロジックに関係ないけどユースケースを満たすためには必要な処理も実装する
    - https://qiita.com/tono-maron/items/345c433b86f74d314c8d

- 純粋なレイヤードアーキテクチャ
    - ドメインモデルパターンを使う場合
        1. domain層とinfra層の間だけinterfaceを使わないパターン
            - domain層の中にinfra層にアクセスするクラスを別ファイルで作成する。そのクラスはinfra層にアクセスしてCRUD操作を実現するためのクラス。
            - domain層でさらに別にmodelのクラスを別ファイルで作成する。これがビジネスロジックのためのもの。単なるCRUDの場合、modelはドメインモデル貧血症になる。(簡単なアプリだからしょうがない)
            - 勘違いしやすいのが、modelのクラスにinfra層へのアクセス(CRUD)を書いてしまうこと。これはダメ。
        2. domain層とinfra層の間にinterfaceを使うパターン
            - 「domain層の中にある「infra層にアクセスするためのクラス」」と「infra層」はinfra層にinterfaceを記述して依存させる
            - 「ユースケース層」と「domain層の中にあるmodelクラス」はmodelクラスの中にinterfaceを記述して依存させる
    - トランザクションスクリプトパターンを使う場合
        1. 1,2をトランザクションスクリプトパターンで行う場合
            - infra層のinterfaceを持った構造体を定義して、メソッドとしてビジネスロジックを記述する。メソッドの引数や戻り値にmodelの構造体を使う。CRUDはinfra層のinterfaceを介して取得する。
            - modelはプロパティのみの構造体を定義する
            - アプリケーションアーキテクチャ設計パターンのP157-162を参考にするとわかりやすい
    - https://qiita.com/tono-maron/items/345c433b86f74d314c8d

- プレゼンテーション層とdomain層の間のデータのやり取りにDTOを使うか否か
    - 制約の緩いレイヤードアーキテクチャなら直接参照してもいいが、制約の厳しいレイヤードアーキテクチャならDTOを使う。
    - https://github.com/little-hands/ddd-q-and-a/issues/81

- domain層とinfra層の間のデータのやり取りにDTOを使うか否か
    - DDDの場合は循環参照にならないからDTOを使う必要はない
    - 純粋なレイヤードアーキテクチャの場合は循環参照になってしまうのでDTOを使う
    - https://qiita.com/tono-maron/items/345c433b86f74d314c8d

---

- サーバサイドのMVCってなに？
    - Viewがjson形式で返す
        - いつものViewはHTML形式で返す
    - Controllerはクライアントのリクエストを受け付けて、それに合ったModelを起動する
    - modelはいつも通り
https://qiita.com/ffggss/items/15943c6c3908a6f25cb5

- Lambda+レイヤードアーキテクチャ
    - APIサーバをレイヤードアーキテクチャで実装してLambdaに載せて、アクセスポイントをAPI Gatewayで構築しているだけ
    - repositoryはデータの永続化に関わるinterfaceを書くところ
https://tech.willgate.co.jp/entry/2020/03/10/173000

- DDDにおけるレイヤードアーキテクチャのアプリケーションサービスとドメインサービスのちがい
    - ドメインサービス
        - EntityまたはValue Objectのいずれかに入れるのは不自然な場合に定義するクラスのこと。ビジネスロジックを協調動作させるクラス。
    - アプリケーションサービス
        - アプリケーションの一つのユースケースを満たすときに、プッシュ通知やメール通知などドメインに関係ない処理が必要になることがある。「ドメインに関係ない処理」+「ドメイン層のビジネスロジック呼び出し」+「ドメイン層のドメインサービス呼び出し」が責務になる。
https://blog.j5ik2o.me/entry/2016/03/07/034646

- ドメインモデルを使う場合
    - ドメインサービスでビジネスロジックの協調動作をさせる。これをドメイン層で行う。
    - プッシュ通知、ドメイン層の呼び出しをユースケース層で行う。
- トランザクションスクリプトを使う場合
    - 「DTOのクラス」と「振る舞いだけのクラス」に分けて、これをドメイン層とする。ビジネスロジックの協調動作もメソッド化して自由に配置していい。制約が緩い。
    - プッシュ通知、ドメイン層の呼び出しをユースケース層で行う。
    - ドメイン層が大した記述がない場合、ユースケース層に統合されて3層として扱うこともある
- テーブルモジュールを使う場合
    - データベースのカラムを模倣したパターン
    - RDBならドメインモデルとアクティブレコードを組み合わせるパターン
    - NoSQLの場合にも使われる
https://scrapbox.io/kawasima/レイヤードアーキテクチャ
http://blog.fujimisakari.com/web_application_architecture_pattern/

- トランザクションスクリプトの問題点と解決策のDDDとレイヤードアーキテクチャ
https://www.yo1000.com/ddd-transcript

- 色々なレイヤードアーキテクチャ
https://scrapbox.io/kawasima/レイヤードアーキテクチャ

---

- アーキテクチャの変遷
    1. Viewだけ
        - Viewにロジックなど何でも突っ込む構築
        - FatViewに陥る
    2. PDS(MVC)+2層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ユースケースを実行する場合はファサードを呼び出して、簡単なCRUDならそのままModelを呼び出す感じかな？
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - BusinessLogic層
            - サービスレイヤ
                - ファサード(facade)というデザインパターンを適用するための関数を定義してユースケースの役割を担わせる
                - ファサードは複数のビジネスロジックを順番に実行する関数
                - サービスレイヤはModelと同じpackageだけど、Modelのクラス内には定義しない(多分)。外部に関数として定義
            - Model
                - ビジネスロジック(データと振る舞い)を定義する
        - FatViewを解決するために考案
        - プレゼンテーション層とドメイン層を分離することが目的(詳しくはPDSの自分の解説)
        - MVCフレームワーク+ORMに沿って開発すると、このPDS(2層)を実現することになる
        - MVCフレームワークはVCとMの間にinterfaceを使うことで疎結合にしていると思われる(たぶん。推測。)
    3. PDS(MVC)+3層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ユースケースを実行する場合はファサードを呼び出して、簡単なCRUDならそのままModelを呼び出す感じかな？
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - BusinessLogic層
            - サービスレイヤ
                - ControllerとModelの密結合を回避するためのレイヤ(ユースケースを満たす役割)
                - ファサード(facade)というデザインパターンを適用するための関数を定義してユースケースの役割を担わせる
                - ファサードは複数のビジネスロジックを順番に実行する関数
                - サービスレイヤはModelと同じpackageだけど、Modelのクラス内には定義しない(多分)。外部に関数として定義
            - Model
                - ビジネスロジック(データと振る舞い)を定義する
        - DataAccess層
            - 2の概念にデータアクセス層が加わることで、生のSQLや外部APIを扱うことを容易にする
    4. PDS+4層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ロジックはusecase層を呼び出すことで取得
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - Usecase層
            - 3のファサードを改めてここのusecase層に分離している
        - Domain層
            - ビジネスロジック(データと振る舞い)を定義する
        - DataAccess層
            - 生のSQLや外部APIを扱うことを容易にする
        - 3のBusinessLogicのサービスレイヤをusecase層として定義するアーキテクチャ
            - つまり、BusinessLogic層をUsecase層とDomain層に分割するということ
    5. PDS+DDD(3,4層)
        - DIPを使って依存関係を逆にする
    6. PDS+DDD(クリーンアーキテクチャ)
        - まだわかっていない
    7. DDD+CQRS
        - https://www.slideshare.net/mobile/dcubeio/ddd-cqrs-orm
    8. マイクロサービスアーキテクチャ
    9. その他のアーキテクチャなど
        - 40ページ目に色々載っている
            - https://www.slideshare.net/mobile/AtsuoAoki/ddd-201811
        - POSAに載っている色々なアーキテクチャ
            - https://qiita.com/y_ujitoko/items/aa82d3b49850e0bbca32
    - 注意点
        - レイヤードアーキテクチャは同一層同士は参照できる。だからMVCのVとC同士は参照できる
        - プロジェクトの規模によって選定して、やり過ぎたアーキテクチャを選定しないようにする
        - 純粋なレイヤードアーキテクチャを採用する時はusecaseとinfraの間でusecaseのmodelをinfraが参照しようとすると循環参照になってしまうので、DTOを使ってデータを伝搬させるようにする。DTOというのはData Transfer Objectというクラスで、データを変換したり交換する時に使用される。
            - go言語のcontextを全部のレイヤーでimportするとオブジェクトの交換でなくてもいける？？
    - 参考文献
        - MVCのベストプラクティス
            - https://rabbitfoot141.hatenablog.com/entry/2018/10/16/194555
        - FatController撲滅運動
            - https://www.slideshare.net/OhasiYuki/ss-52193845
        - webアプリケーションの設計パターン
            - http://blog.fujimisakari.com/web_application_architecture_pattern/

<br></br>

- アーキテクチャの変遷(条件を緩めたver)
    - リラックスレイヤシステム
        - http://yusuke-ujitoko.hatenablog.com/entry/2016/11/15/230224

## 実際に開発するときに見ること

- アーキテクチャの選択
    1. MVCフレームワークのORMで足りる
        - MVCフレームワークに沿って開発すれば良い(PDSの概念を取り入れるだけでいいということ)
    2. 複雑なDBのクエリを書くからORMでは足りない
        - PDSに加えてシステムアーキテクチャを取り入れる
            - 3層アーキテクチャ
                - infra層をusecase層から分離できるから、生のSQLを使ったプログラムでもコードをクリーンに保てる
            - 4層アーキテクチャ
                - usecase層からdomain層を分離できるので、usecase層が複雑になった場合などに有効
            - クリーンアーキテクチャ
                - あとで追記する

- レイヤードアーキテクチャ+DDDを実装するときに役に立つ図と解説
    - レイヤードアーキテクチャ(3層でも4層でも)を採用することで関心の未分離問題を解消
        - レイヤーを一つ飛ばしでアクセスしてしまう問題のこと
    - interfaceを使うことで密結合問題1を解消
        - 直接メソッドを呼び出してしまっている問題
        - 仕様変更に対応しやすい、機能追加がしやすい
        - Testable(単体テスト)なコードの実現
    - DI(Dependency Injection)を使うことで密結合問題2を解消
        - インスタンスを依存先のクラスで持ってしまっている問題
        - Testable(単体テスト)なコードの実現
    - DIPを使うことでdomain層とinfra層の依存関係を逆転
        - これはオプション
        - 変更されにくいdomain層を最下層に持っていける

    ![clean_architecture](https://user-images.githubusercontent.com/53253817/99709796-16006700-2ae3-11eb-8eab-8ac9c5445a54.png)

- わかったこと
    - interfaceとDIを使うことは必須
        - どちらもテスダブル(特に単体テスト)なコードを実現するのに必要
    - 3層、4層、クリーンなどのどれにするかは規模やチームによる
        - 個人開発の小規模なアプリケーションは3層で十分な気がしてきた
    - infra層のDIPはオプション
        - DDDを取り入れるならDIPを行う


---

## アプリケーションアーキテクチャを取り入れた開発をするときにわからなくなったら見ること

- PDS(presentation domain separation)
    - プレゼンテーション層とドメイン層を分離すること
        - プレゼンテーション層の設計にフォーカスしたもの。プレゼンテーション層に当てはまらない余り物をドメイン層に配置する
    - なぜプレゼンテーション層とドメインに分割するのか？
        - 関心の分離をすることが目的
        - プレゼンテーション層はコードによるテストが困難だから。他の層はカードによるテストで自動化したいから分離をしないと単体テストができない。
        - プレゼンテーション層は専門性が高いから分業する仕組みが欲しい
    - MVC,MVVM,MVPといった概念がこれにあたる
        - VCがプレゼンテーション層に。それ以外のものをMに詰め込んでドメイン層とする。

- アプリケーションアーキテクチャ
    - PDSだけではドメイン層(Model)が複雑になり過ぎてしまうから、さらに関心を分類することが必要になったことから生まれた
    - レイヤーアーキテクチャ(3層、ドメイン層をusecaseとinfraに関心を分離した)
        - presentation層
            - VCに当たる部分。UIを実現する。
        - usecase層
            - ビジネスロジック層。
            - 「ユースケース単位」でクラスを分割
                - ユースケース図に書かれた一つ一つがクラスに分割される
            - 重要なのはルールや制約も含まれること
        - infra層
            - 外部API通信、SQL発行
    - レイヤーアーキテクチャ(4層、usecase層からドメイン層を抜き出して関心を分離した)
        - presentation層
            - VCに当たる部分。UIを実現する
        - usecase層
            - 「ユースケース単位」でクラスを分割
                - ユースケース図に書かれた一つ一つがクラスに分割される
            - ルールや制約は含まない
        - domain層
            - ビジネスのルールや制約(メソッド、プロパティ)
            - アプリケーションの流れではなくて判定とかそっちのロジックが含まれる感じ
                - アプリケーションがなくても現実世界で存在するルール。アプリケーションがない世界でどのように実現するか考えた時のルールを考えるとdomain層に割り当てられるべきものがわかるかも
        - infra層
            - 外部API接続、SQL発行

- アーキテクチャの実装の遷移
    1. とりあえずレイヤーごとに分割して実装
        - 関心の未分離が問題
            - レイヤーを一つ飛ばしなどでアクセスしてしまっているということだと思う
    2. 飛ばして参照されている処理を違うレイヤーに移送して実装
        - レイヤー間が密結合な問題
            - レイヤー間で直接メソッドを参照している
    3. interfaceを使って利用者がinterfaceにのみ依存するよう実装
        - レイヤー間が密結合な問題2
            - インスタンスを生成する箇所がクラスに依存してしまっている
    4. DIまたはservice rocatorを使用

- 参考文献
- 色々なアーキテクチャ
https://qiita.com/YutoMizutani/items/260f684871b77732e18f

- なぜMVCが生まれたか
http://memowomome.hatenablog.com/entry/2014/04/13/102736

- interfaceを使う理由、レイヤーに分ける理由
https://www.slideshare.net/mobile/AtsushiNakamura4/ss-79365929

- 関心の分離
https://qiita.com/MinoDriven/items/37599172b2cd27c38a33

- ユースケース層とドメイン層の違い
https://little-hands.hatenablog.com/entry/2019/07/26/domain-knowledge
