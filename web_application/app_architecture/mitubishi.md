# アプリケーションアーキテクチャ設計パターン書籍メモ

## 設計前知識
- アプリケーションアーキテクチャは個々のユースケースを開発する前に決めておく必要がある

- ウォーターフォール開発とアジャイル開発においてアプリケーションアーキテクチャの設計の重要性は同じ
    - アジャイル開発ではアーキテクチャをそこまで考えなくてもいいのかと言われるとそうではなくて、アジャイル開発はあくまでも一つ一つのユースケースを開発して、すぐにリリースするという開発方法なので、骨格となるアーキテクチャにユースケースを加えていくという開発方法になる。つまり全体の骨格としてアプリケーションアーキテクチャはしっかり設計しておく必要がある。
        - 例えば、全体としてはレイヤードアーキテクチャを採用して、アジャイル開発によってユースケースをそのアーキテクチャに適宜追加していくというのがアジャイル開発になる
        - ウォーターフォール開発に関しては、ユースケースを全て実装し終わってからサービスを稼働するといった感じ
        - 近年のマイクロサービスアーキテクチャはこれに当てはまらないかもしれない

- 実際の大人数の開発
    - アーキテクトがアプリケーションアーキテクチャやユースケースを決める
        - ユースケース図、シーケンス図、アクティビティ図を作成することの重要性がわかったかも

<br></br>

- 同期・非同期
    - 同期呼び出し
        - 処理Aが処理Bの結果を待って、処理を中断する方式
    - 非同期呼び出し
        - ポーリング方式
            - 処理Aが処理Bが終わったかを逐次確認する
            - 確認しながら別の処理をする
        - コールバック方式
            - 処理Bが処理Aに終わったら通知する方式
            - その間処理Aは別の処理をする

    - P29,30の図

- 逐次・並列・並行
    - どっかのreadmeにまとめた

<br></br>

- 処理形態
    - オンライン処理
        - ユーザと画面を通じて対話をしながら処理を行うアプリケーション
        - 同期型と非同期型がある
            - 同期型はユーザが処理を待つ必要があるが、実行結果をその時点で受け取ることができる
            - 非同期型はユーザが処理を待つ必要がないが、実行結果をその時点で受け取ることができないので、「照会機能やサーバプッシュ」などで実行結果を確認する必要がある。「スレッドによる非同期呼び出し」や「メッセージキューイング方式」といった方法で実現する
            - 31の図
    - バッチ処理
        - あらかじめ蓄積されたデータに対して、一括で処理を行うアプリケーションの形態
        - オフラインバッチとオンラインバッチがある

<br></br>

- webアプリケーションのレイヤとシーケンス図を合わせた図(わかりやすい)
    - p36

- 各レイヤの機能
    - プレゼンテーション層
        - 有効なユーザかのチェックをし、必要に応じてユーザ認証を行う
        - 有効なユーザの場合、入力値のオブジェクト変換、バリデーション、セッション管理などを行う
        - ロジックの部分は後続のビジネスロジック層に任せて、返ってきた値とテンプレートをレンダリングしてユーザにレスポンスを返す
    - ビジネスロジック層
        - プレゼンテーション層やアプリケーション層から受け取った入力値をもとにビジネスロジックを実行するところ
        - ビジネスルールのチェック、既存のデータとの整合性のチェック
        - インフラ層のために、データの整形なども行う
    - インフラ層
        - 「RDBアクセス」、「アプリケーション連携」、「MOMアクセス」を担うところ
        - RDBアクセスのみを扱う場合はデータアクセス層という
        - アプリケーション連携は外部APIを使うときなど

- DTO
    - 状態の保持のために作成されたクラス
    - 「フィールド+アクセッサメソッド」だけを持つクラス
        - アクセッサメソッドは、getterやsetterのこと
    - 基本的に振る舞いは保持しない。せいぜい「フィールドの型変換、フォーマットの型変換」のメソッドを保持するくらいに留める
        - 「文字列<->日付」や「数値<->列挙型」など
    - ビジネスロジック層にトランザクションスクリプトパターンを適用する時や、データアクセス層でテーブルデータゲートウェイパターンを適用する時に、「各レイヤ間の受け渡しのためのオブジェクト」として使われる
    - 「レイヤ間の受け渡しのためのオブジェクト」という使い方としての例で、純粋にレイヤードアーキテクチャを構築したときのdomain層とinfra層のデータの受け渡しで使っている例があった

<br></br>

- スコープ
    - リクエストスコープ
        - 一つのリクエストに結びつく記憶領域
            - 一つのリクエストからレスポンスの間
        - requestという名前がついている
    - セッションスコープ
        - 一つのHTTPセッションに結びつく記憶領域
            - ログインからログアウトまで
        - 同一ユーザの複数リクエストにまたがってデータを保持
        - sessionという名前がついている
    - アプリケーションスコープ
        - 一つのwebアプリケーションに結びつく記憶領域
            - アプリケーションの開始から終了まで
        - 複数ユーザ間でデータを共有できる
        - contextっていう名前がついているっぽい

<br></br>

- レイヤードアーキテクチャとは依存関係が上位レイヤーから下位レイヤーへ一方向のもののこと。各レイヤーにinterfaceが設けられていなくても、レイヤードアーキテクチャと言う。それぞれの層が相手の層のインスタンスを持つことになる。
    - このアーキテクチャにMVCを導入した場合(P55の図がわかりやすい)
        - controller
            - ユーザから入力値を取得
            - modelを呼び出してビジネスロジックを実行
            - templateと返り値をレンダリングするためにViewを呼び出す
        - model
            - 状態と振る舞いを保持する
                - 「状態」という考え方が重要。振る舞いが「状態」を変化させたり、DBに格納するためにinfra層に「状態」を渡したり、DBからの返り値を「状態」に反映させたりする。
                - アクセサメソッドも持つことあり
                - トランザクションスクリプトで行う場合は、状態を保持しないでステートレスとなり、振る舞いの部分だけを持つクラスになる。つまり、ユーザの入力が直接に関数の引数に渡されるということ。
            - コンストラクタで初期値(状態)をセットする
            - メソッド(振る舞い)を呼び出して実行
        - view
            - templateとtemplateエンジン

<br></br>

## プレゼンテーション層の設計パターン

- webブラウザを経由した外部システムとの連携
    - リダイレクト方式
        - 他システムのURLにクエリ文字列を付与して連携する方式
    - 空ページ自動サブミット方式
        - わからん

<br></br>

- ブックマーカブル

<br></br>

- セッション管理と負荷分散の設計
    - スティッキーセッション方式
        - p64
    - セッションレプリケーション方式
        1. スティッキーセッション方式と組み合わせるパターン
        2. リクエストをラウンドロビンするパターン
        - p65
    - データベースセッション方式
        - p66
- セッション管理のその他の機能
    - セッションタイムアウト
    - セッションリスナ


<br></br>

- 認証とログイン・ログアウト
    1. HTTPの仕様を使った方式
        - BASIC認証
        - DIGEST認証
    2. Java EEコンテナの機能を使った方式
    3. アプリケーションとして実装する方式
        - djangoとかを使ったり、go言語ならそのまま作る
        - セッション変数に格納するやつ
        - 通常はフィルターを使って実装される
    4. SSOサーバで認証する方式
        - リバースプロキシ型
        - エージェント型

<br></br>

- ウィンドウ制御
    - ユーザが複数ウィンドウを立ち上げて操作するときの制御の仕方
- 制御方式一覧
    1. シングルサブウィンドウ方式
    2. マルチウィンドウ+不整合チェック方式
    3. マルチウィンドウ+並行操作可能方式

<br></br>

- 不正な更新リクエスト対策
    1. webブラウザのキャッシュ無効化
    2. トークンチェック
    3. POST-REDIRECT-GETによる画面遷移
    4. カンバセーションスコープ
    5. サニタイジング
- 対策の組み合わせ
    - 更新処理を行なった後、戻るボタンで前の画面に戻り、再びサブミットする
        - 1,2,4
    - 更新処理を行なった後、結果画面で更新ボタンを押下する
        - 2,3,4
    - XSS攻撃
        - 5
    - CSRF攻撃
        - 2

---

## インスタンスの生成や構造に関する設計パターン

- 複数のスレッド間で共有されるインスタンスの不正な更新対策
    1. 状態(インスタンス変数)を持たないインスタンスにする
    2. イミュータブルオブジェクトにする
        - 全てのインスタンス変数をprivate及びfinalで修飾する
        - 全てのインスタンス変数はコンストラクタで初期化する
        - ゲッタは宣言するが、セッタは宣言しない
    3. 状態(インスタンス変数)への更新処理をsynchronizedブロックで同期化する
    - 以上の対策が施されたインスタンスを「スレッドセーフ」であると言う。

<br></br>

- アプリケーションによるライフサイクル管理
    - リクエストのライフサイクルに結びつくインスタンス
    - httpセッションのライフサイクルに結びつくインスタンス
    - webアプリケーションのライフサイクルに結びつくインスタンス
    - シングルトン
    - スレッドローカル

<br></br>

- 依存性解決のための設計パターンとDI
    - クラスからクラスの呼び出し方(FooとBarクラスを例に)
        1. Barインスタンスを直接生成(new)する
            - クラス間が密結合になる
        2. Barを実装とインタフェースに分離し、ファクトリによってインスタンスを取得する
            - クラス間が疎結合になる
        3. Barを実装とインタフェースに分離し、DIによってインスタンスを取得する
            - クラス間が疎結合になる
            - スレッドセーフなど気にしないとダメ

<br></br>

- AOP(アスペクト指向プログラミング)
    - 複数のクラス間で、同じ機能を共有したい場合に使う
    - 共有したい機能のコードの記述箇所は、一箇所にまとめたい場合に使う
        - ユーティリティクラスを使わない方法
        - 対象となるクラスに後から織り込む
- AOP対象の機能(横断的な関心)
    - ログ出力
    - トランザクション管理
    - 例外ハンドリング
    - カスタムアノテーションによる独自インジェクション
    - メソッド引数に対する汎用的なバリデーション

<br></br>

- 下位レイヤから上位レイヤの呼び出し
    1. Observerパターン
        - SPAのMVxパターンでもビューがモデルを監視するときに使われたりする
    2. Plugin Factoryパターン
- 下位レイヤから上位レイヤへの依存は極力回避する必要がある。そこで上のパターンを使うと依存することなく上位レイヤを呼び出せる

---

## ビジネス層の設計パターン

- Domain Modelパターン
    - 一つのクラスの中に状態(フィールド)と振る舞い(メソッド)を実装するパターン
        - このようなクラスをドメインオブジェクトという
    - ドメインオブジェクト同士が関連や継承といった関係性を持ち、ポリモーフィズムというOOP最大の利点を駆使して開発を行う
- Transaction Scriptパターン
    - 状態(フィールド)を保持するクラスと、振る舞い(メソッド)をもつスタートレスなクラスとを分離して別々に実装するパターン
        - 会員クラスは氏名とクレカ情報だけ
        - 注文サービスクラスは注文するメソッドを持つ
    - データアクセス層にはTable Data Gatewayパターンを採用して、DAOを経由して対象テーブルへアクセスするのが一般的

<br></br>

- Transaction Scriptパターンによるビジネスロジック構築

- Transaction Scriptパターンの処理フロー
    - DTOを媒介としたパイプライン処理
    - P157

- ビジネスロジックの共通化
    - ユーティリティクラスを含めて、ビジネスロジック(メソッド)を共通化するための戦略
    1. 同一クラス内の複数メソッドで同じような処理があった場合
        - 当該クラスのprivateメソッドに実装する
    2. 同一のDTOを引数に取るような比較的役割が近い複数クラス間で同じような処理があった場合
        - 当該の複数クラスのスーパークラスを作成し、そのメソッド(通常はprotected)に実装する
    3. 様々なユースケースの複数クラス間で同じような処理があった場合
        - ユーティリティクラスを作成し、そのメソッド(通常はpublic)に実装する

- ビジネスロジックのクラス分割方針
    - 一つのユースケースがビジネスクラスの一つのメソッドに対応する
        - 「注文する」にOrderServiceクラスのplaceOrderメソッド
        - 「返品する」にReturnServiceクラスのreturnProductメソッド
    - クラス分割は制約がなく、開発者の裁量によって決まる。なので設計に一貫性がなくなる可能性がある

- 機能拡張への対応
    - 工数が膨らむ可能性が高い

<br></br>

- Domain Modelパターンによるビジネスロジック構築

- DDDにおいてドメインオブジェクトの構成要素にEntityとValue ObjectとDomain Serviceの3種類がある
    - EntityとValue Object
        - 違いが難しいので、P163参照
    - Domain Service
        - 何らかの振る舞いのみを表すオブジェクトなのだ、通常はステートレスになる
        - EntityかValue Objectのどちらに入れても不自然になってしまうメソッドをDomain Serviceとして独立させる
        - 「入金する」や「出金する」は「口座」という名詞に属する振る舞いだが、「振替する」は二つの「口座」を行き来するからどこかに属するよりもServiceに入れた方がいい

- Application Service
    - 業務要件とは直接関係のない共通的な処理を行う場所
    - 多分他でユースケース層として紹介されているところだと思うのだが、この本だとユースケースはDomain Serviceによって実行されるっぽい。それはDDDだからなのかな？ただのレイヤードアーキテクチャならここにDomain Serviceの役割を書くのかな？わからん。

- Domain Modelの全体的な処理フロー
    - P165

- ビジネスロジックの効率的な構築方法
    - P173-183

---

## トランザクション管理とデータ整合性確保のための設計パターン
- P184-213

---

## データアクセス層の設計パターン


