# 安全なWebアプリケーションの作り方 書籍メモ

---

- あとでやるところ
    - hiddenパラメータと脆弱性について
        - P54-57
    - Cookieの属性のセキュリティ事項
        - P69-72

---

- IPAの「安全なWebサイトの作り方」ガイドライン
    - https://www.ipa.go.jp/security/vuln/websecurity.html

---

- HTTPリクエスト(GET)
    
    ![2020-10-31 0 09のイメージ](https://user-images.githubusercontent.com/53253817/97722156-a7e10980-1b0d-11eb-81e3-c6e9a2862529.jpeg)

    ![2020-10-31 0 10のイメージ](https://user-images.githubusercontent.com/53253817/97722205-b92a1600-1b0d-11eb-85e0-fe04079b880d.jpeg)

- HTTPリクエスト(POST)

    ![2020-10-31 0 09のイメージ](https://user-images.githubusercontent.com/53253817/97722172-ac0d2700-1b0d-11eb-8fcb-160b0cc3614f.jpeg)

    ![2020-10-31 0 10のイメージ](https://user-images.githubusercontent.com/53253817/97722219-bd563380-1b0d-11eb-86f7-4444ded4340e.jpeg)

- HTTPレスポンス

    ![2020-10-31 0 10のイメージ (1)](https://user-images.githubusercontent.com/53253817/97722227-bfb88d80-1b0d-11eb-9182-1d707ae3a689.jpeg)

    ![2020-10-31 0 11のイメージ](https://user-images.githubusercontent.com/53253817/97722233-c34c1480-1b0d-11eb-9dd2-e82505521e88.jpeg)

- 参考文献
    - https://itsakura.com/network-http-get-post

---

- MIMEとは
    - リソースの種類のこと
    - text/plain
        - テキスト
    - text/html
        - html文書
    - application/xml
        - xml文書
    - imae/gif
        - gif画像
    - etc

---

- GETとPOSTの使い分け
    - GETメソッドはリソースの取得のみに用いること
    - GETメソッドは副作用がないことが期待される
        - 副作用というのは、リソースの削除とか更新されることが起きないということ？
    - 秘密情報の送信にはPOSTメソッドを用いること
        - GETだと何がダメかと言うと
            1. URL上に指定されたパラメータがReferer経由で外部に漏洩する
            2. URL上に指定されたパラメータがアクセスログに残る
            3. URL上のパラメータがブラウザのアドレスバーに表示され他人にのぞかれる
            4. パラメータつきのURLを利用者がソーシャルネットワークなどで共有してしまう
- まとめ(以下が一つでも当てはまる場合にPOSTを使い、それ以外はGET)
    1. データ更新など副作用を伴うリクエストの場合
    2. 秘密情報を送信する場合
    3. 送信するデータの総量が多い場合

---

- 認証の種類
    - Basic認証
        - Basic認証はステートレスなので、ログアウトの概念がない
        - Webサーバの設定で実現されることが多いが、プログラムでもできる
    - フォーム認証
        - HTMLフォームでIDとパスワードを入力させる
    - クライアント認証
        - TLSクライアント証明書を用いる
    - Digest認証

---

- Cookieがアプリケーションデータを保持する目的で使われない理由(IDとかパスワードの格納とかに)
    - Cookieが保持できる値の個数や文字列長には制限がある
    - Cookieの値は利用者本人には参照・変更できるので、秘密情報の格納には向かない

- CookieはセッションIDを格納するために使い、実際のアプリケーションデータを格納するのはセッションが担う

- セッションIDに求められる要件
    1. 第三者がセッションIDを推測できないこと
        - セッションIDの生成には、暗号論的擬似乱数生成器を使う
        - セッションIDの生成はフレームワークなどに任せる
    2. 第三者からセッションIDを強制されないこと
        - セッションIDの固定化攻撃というものがある
    3. 第三者にセッションIDが漏洩しないこと
        1. ネットワーク的にセッションIDが盗聴される
        2. クロスサイトスクリプティングなどアプリケーションの脆弱性によって漏洩
        3. PHPやブラウザの脆弱性により漏洩
        4. セッションIDをURLに保持している場合は、Refererヘッダから漏洩する
        5. クッキー発行の際の属性に不備がある

- セッションIDがクッキー発行の際の属性に不備がある影響で漏洩する問題
    - 

---

- CORSと同一オリジンポリシー
    - https://yamory.io/blog/about-cors/

---

- Webアプリケーションの機能と脆弱性の全体像
    - P98の画像

---

- インジェクション系の脆弱性は同じような原理で起こる
    - データの引用符('や")やデリミタといったものを使って行われる
    - P100の画像

---

- バイナリセーフとは
    - バイナリセーフな関数
        - バイナリデータ(終端文字を表す¥0など)を正しく扱うことができる関数
    - バイナリセーフでない関数
        - バイナリデータ(終端文字を表す¥0など)を正しく扱うことができない関数

- ヌルバイト攻撃
    - ヌルバイト攻撃とは
        - バイナリセーフでない関数にヌルバイトを含めることでセキュリティチェックを潜り抜ける方法

    - ヌルバイト攻撃は単独で行われることはない
        - 脆弱性の対策をかいくぐる目的で使われる
        - XSSやディレクトリトラバーサルと組み合わせて攻撃されることが多い
    - 対策方法
        - バイナリセーフな関数を用いて、入力が来た文字列にヌル文字が含まれていないかを判定して、含まれていたら弾く処理を行う

---

- クロスサイトスクリプティング(XSS)でCookieを乗っ取り
    1. 偽のサイトに誘導
    2. 偽のサイトでは、iframeを使って本物のサイトの脆弱性のあるページを表示する
        - 自動的にそのページ上でcookieの値をクエリ文字列に入れて、情報収集サイト(偽のサイト2)に遷移する
    3. 情報収集サイトのURLにはクエリ文字列でcookie(本物のサイトのセッションID)が渡されているから、あとはその値を攻撃者にメールで送ることで、完了
    - P122-124

- クロスサイトスクリプティング(XSS)でHTMLのフォームを書き換え

- これらの脆弱性は入力値をエスケープ処理をしていないことが問題
    - メタ文字と呼ばれる特殊な文字列のこと

---



---




# 開発に必須な知識まとめ
## 認証
- フォーム認証の手順
    1. 事前準備
        - userのデータベースを作成する
            - userの登録されている認証情報などを格納する
            - 「ID、セッションID、name、email、password」ここら辺は必須だと思う
        - セッションのデータベースを作成する
            - セッションが作成されたときに格納するデータベース
            - 「ID、セッションID、email、userID」ここら辺は必須だと思う
        - HTMLフォームを作成しておく
    2. POSTリクエストからemailの値を取得して判定
        - フォームに入力されて来るのでPOSTリクエストが来る
        - if文で存在するユーザか確認
        - 存在するユーザだった場合、次にパスワード認証する
    3. POSTリクエストからpasswordの値を取得して判定
        - 「データベースに保存された暗号化されたパスワード」と「POSTリクエストで来た暗号化されたパスワード」が同じか判定
    4. セッションを作成する
        - 認証されたらセッションを作成してデータベースに登録する
    5. Cookieを作成する
        - セッションIDをCookieに入れて送る
        - この際にHTTPまたはHTTPSからしかCookieにアクセスできないようにする
        - Cookieを作成したらレスポンスヘッダにCookieを設定する
    6. リクエストが来たページにリダイレクトする
        - ホームページに飛ばすのでもいいけど、ユーザがリクエストしてきた会員ページに飛ばす方がUI的にはいいと思う
    7. セッション関数を作成して認証をし続ける
        - 会員しか行えない動作や会員にしか開示されないページを表示する前に、セッション関数を呼び出すことでログインされているかを判定する
        - セッション関数の処理内容
            1. HTTPリクエストにCookieが存在するかどうか判定
                - ない場合はloginページにリダイレクト
            2. 「HTTPリクエストのCookie内のセッションID」が「データベース内のセッションID」に該当するものがあるか判定
                - ない場合はloginページにリダイレクト
                - ある場合はセッション情報をreturnする
                    - セッション情報をreturnする理由は、セッションの情報を使いまわせるから
                    - 例えば、会員と非会員で同じwebページを表示するけど、ナビゲーションバーだけ変更したい場合は、ifでセッションを確認すると簡単に実装できる

## CookieとSession
- Cookieの重要な属性
    - Domain
        - ブラウザがクッキー値を送信するサーバのドメイン
    - Path
        - ブラウザがクッキー値を送信するURLのディレクトリ
    - Expires
        - クッキー値の有効期限。指定しない場合はブラウザの終了まで
    - Secure
        - HTTPSの場合のみクッキーを送信
    - HttpOnly
        - この属性が指定されたクッキーはJavaScriptからアクセスできない
- DomainとSecureとHttpOnlyが重要事項
    - Domainは設定してはいけない
        - クッキーモンスターバグというものがある
    - Secureはtrueにするべき
        - httpとhttpsが混在するページに関しては、この設定だけだと、ひと工夫加えないと通信できなくなってしまう可能性があるので注意
    - HttpOnlyはonにするべき
        - クロスサイトスクリプティング攻撃によってクッキーを盗まれてしまう可能性を防ぐ
        - 完全に防げるわけではないが、攻撃を難しくすることはできる

## webアプリケーションの入力処理での対策(ヌルバイト、XSS、SQLインジェクション対策)
- HTTPリクエストが飛んできた時に、どのような入力値の判定をするかということ
- 以下のように色々やらなくても、もしかしたら全ての入力に対してエスケープ処理を施すだけでいいのかもしれない

- 入力値の判定手順(フレームワークの入力機能を使えば以下のことはすべて満たしていると思う。)
    1. 文字エンコーディングの妥当性検証
        - 入力された文字列の文字コードが正しいかを判定すること
            - 文字コードはUTF-8とかShift-JISとかのこと
        - 文字コードが正しくない場合は正しい文字コードで入力するように促す
        - 文字コードが正しい場合は入力を受け付ける
        - pythonならchardetライブラリで判定できる
    2. 文字エンコーディングの変換(必要な場合のみ)
        - Shift-JISからUTF-8に変換したりする
    3. 入力値の妥当性検証(正規表現で行う)
        - 制御文字のチェック
            - 改行とかタブのこと
            - ヌルバイトが含まれていたら弾く
            - ASCIIコード0x20未満と0x7Fの文字を弾く
        - アプリケーションの仕様外のチェック
            - 電話番号なら数字のみ受け付ける
            - ユーザIDなら英数字8文字のみ受け付ける
                - 文字数を制限することで、XSSの脆弱性があっても危険なスクリプトを書けないといった防ぎ方ができる
            - 数値が最大値、最小値の範囲内にいることを確認
        - 入力された値が配列かどうかチェック
            - 入力された値がスカラーでない場合に予期せぬバグをうむ可能性があるから

## Webアプリケーションの表示処理での対策(ヌルバイト,XSS、SQLインジェクション対策)
- 大事なのはユーザから入力されてきた値は、クライアントに出力する前に。全てエスケープ処理を施すことが大事
    - エスケープ処理というのは、メタ文字を特殊な文字として認識するのではなくて、ただの文字列と認識させるための処理
    - エスケープ処理はgo言語ならHTMLEscapeStringやJScapeStringを使うとできる
        - https://blog.k-bushi.com/post/tech/programming/golang/build-web-application-with-golang-14/
- 処理手順
    - formを使ってユーザが入力する場合
        - ユーザが入力してきた内容は全てエスケープ処理を施すようにする
            - バックエンドの処理でformから値を取ってくる処理の時にエスケープ処理をしながら取得する
    - クエリ文字列を含んだリクエストが飛んできた場合
        - この場合もクエリ文字列から値を取得する時にエスケープ処理を施す
    - CookieにHttpOnly属性を付与する
        - JavaScriptがCookieを読み出すのを禁止する

## SQLインジェクション対策
- フォームでユーザから入力される時にSQL構文が入力されることで行われる攻撃
    - ユーザから入力されてきたパラメータによって動的にSQLを発行する場合に起こるから、動的に発行する時に以下の対策をすればいい
        - 動的に発行しない時は以下のようなことはしなくていい
            - ユーザから入力されてこない場合の時のこと
- ORMで防げるが、全てをORMで記述してしまうと非効率な構文になってしまい、Dos攻撃に弱くなってしまう可能性が高い

- 完璧な2種類の対策方法
    1. 全ての変数をエスケープする対策
        - それぞれのデータベースが異なるモジュールで提供しているから、それを使用する
        
        ```
        //PostgreSQLの場合はpg_escape_stringで行う
        $sql = "UPDATE user SET name = '".pg_escape_string($_POST['name'])."', age  = '".pg_escape_string($_POST['age'])."' WHERE id = '".pg_escape_string($_SESSION['USERID'])."';";
        ```

    2. 全てのクエリをプリペアードクエリをして実行する対策
        - 実行するSQLを決めておいて、後から値を当てはめる方式のこと
        - プリペアードクエリを使用した場合、入力されるパラメータは全て値として認識される
            - SQL構文としては認識されない
        
        ```go
        //go言語の場合
        statement := "insert into sessions (uuid, email, user_id, created_at) values ($1, $2, $3, $4) returning id, uuid, email, user_id, created_at"
        stmt, err := Db.Prepare(statement)
        err = stmt.QueryRow(createUUID(), user.Email, user.Id, time.Now()).Scan(&session.Id, &session.Uuid, &session.Email, &session.UserId, &session.CreatedAt)
        ```

    - https://gihyo.jp/dev/serial/01/php-security/0005?page=1

## クロスサイトリクエストフォージェリ対策
- 

## クリックジャッキング対策

## セッションハイジャック対策

## セッションIDの固定化攻撃

## 


---
- 負荷分散の時のセッション維持
    - https://www.fujitsu.com/jp/products/network/security-bandwidth-control-load-balancer/ipcom/material/data/1/6.html

- htmlのiframeタグとは
    - 他のHTMLを埋め込むことができる
    - templateタグみたいなものかな


# あとで書くこと
# 認証に関する実装
## ブルートフォース系の対処法
- パスワードポリシーの実装
    - パスワード登録時に辞書によるチェックを行う
        - 使われやすいパスワードの辞書チェック

- 基本的なアカウントロック機能の実装
    1. ユーザID毎にパスワード間違いの回数を数える
    2. パスワード間違いの回数が上限値を超えると、アカウントをロックする。ロックされたアカウントはログインできなくなる
    3. アカウントロックが発生した場合はメールなどで対象利用者と管理者に通知する
        - アカウントロック解除の条件
            1. アカウントロックから30分経過した場合、自動的に再有効化
            2. 管理者が、何らかの方法で本人確認した後に有効化される
                - 1が短い期間に10回行われたら2の方法でロックするとか工夫する
                - 本人と違うIPからアクセスされていることが確認できたら、そのIPをブロックする
    4. 正常にログインした場合は、パスワード間違いのカウンタをクリアする

- 二段階認証の実装
    - 種類
        - メールやSNSで送られる6桁程度の数字
        - スマホアプリなどで生成される6桁程度の数字
    - 実装
        - 初回ログイン時のみ二段階認証を行い、その後は一定期間一段階の認証とする
        - 利用者の通常の使い方から外れたログインの際は、二段階認証をする（地域、時間帯、ブラウザなど）
        - 決済やパスワード変更などの「重要な処理」の際は二段階認証をする

- ログイン失敗時の監視
    - 急激に失敗回数が増えたアカウントの調査をすること
    - 監視する人員が必要になる

- P471のメリデメの画像

- ブルートフォースの種類
    - 一般的なブルートフォース攻撃
        - ユーザIDを固定して、パスワードを変更して試す方法
        - アカウントロックで対処できる
    - 辞書攻撃
        - 使用頻度が高いパスワード候補から順番に試す方法
        - アカウントロックで対処できる
    - ジョーアカウント探索
        - ユーザIDと同じ文字列をパスワードに設定しているアカウントのこと
        - パスワードポリシーの実装で対処できる
    - リバースブルートフォース攻撃
        - パスワードを固定して、ユーザIDを変更して試す方法
        - パスワードポリシーの実装で対処できる
    - パスワードスプレー攻撃
        - ユーザIDとパスワード両方を固定しないで試す方法
            - 少数のパスワードをユーザIDを変更しながら試す方法
    - パスワードリスト攻撃
        - 攻撃対象サイトとは別のサイトから漏洩したIDとパスワード一覧を用いて試す方法
            - 例えば、脆弱なサイトからSQLインジェクションで漏洩したリストを使って、他のサイトを攻撃するとか

---

## パスワードの保管方法
- メッセージダイジェストを使ってパスワードを暗号化
    - ハッシュ関数を使って暗号化する
    - パスワード設定時にハッシュ関数に通したものをデータベースに登録する
    - ログイン時にはハッシュ関数に通したものとデータベースにあるものを照合することで暗号化したまま照合できる
    - P474の画像

- ハッシュ関数をクラックする方法
    - オフラインブルートフォース攻撃
        - 手当たり次第にハッシュ値から元データを得る
    - レインボーテーブル
        - あらかじめハッシュ値が計算されたものが売っていて、それと照合する
        - MD5やSHA-1のものが売っている
        - パスワードを20文字以上にすれば現状は防げる

- ハッシュ解読の対策
    1. ソルト
        - パスワードに乱数を加えることで擬似的に20文字以上のパスワードを作成する
        - ユーザ毎に異なるものにする
            - わずかであるが衝突する可能性はある。極めて低いので無視する
    2. ストレッチング
        - ハッシュ関数を繰り返し適用する
    3. パスワード保存に適した遅いハッシュ関数を使う
        - BCrypt、PBKDF2、Argon2など

---

## 自動ログイン機能の実装
- セッションの寿命を伸ばす
    - CookieのExpiresという属性を1週間などに設定する

- 自動ログインを実現する方法3選
    - セッションの寿命を延ばす自動ログインの実装
        1. 自動ログインにチェックがついている場合は、セッションタイムアウトを1週間に延ばす
            - CookieのExpires属性にも1週間の設定をする
            - ついていない場合は、そのままデフォルトの設定でいい
        2. セッション変数のtimeoutとexpiresにそれぞれの時間を保存する
            - これは自動ログインでなくても行う

    - トークンを使った自動ログインの実装

    - 認証チケットによる自動ログインの実装

- 自動ログインのリスクの低減
    - 重要な動作をする時には自動ログイン中であっても、パスワードを再入力させて、再認証をする
        - 決済するとき、重要な情報を閲覧するとき、パスワード変更、送金

---

## ログインフォーム
- パスワード入力欄はマスク表示する
    - htmlのinputのtypeでpasswordを指定すると隠される
    - 瞳アイコンをクリックすると見れるようにしたほうがいい
        - 常に隠されてしまうと、ユーザが入力しにくいといった理由で、記号を使ったパスワードを設定しない可能性があるから

- HTTPSを使用する
    - 「フォーム入力欄」と「ログイン処理」の二つでHTTPSにする

- ログインIDとパスワードどちらが間違っているかユーザに教える
    - ログイン時にどちらが間違っているか教えてしまうと、攻撃者が片方を固定してブルートフォースができてしまう
        - 最近だと、この考えよりもgmailのログインのように教えてくれるのが増えているらしい
            - ログインの負担を減らすことのよってユーザが複雑なパスワードを設定することを促している
    - 最近はユーザIDを入力させて、「次へ」ボタンを押してパスワードを入力させるという二段階のログインが使われる
        - もしユーザIDが間違っていたら、次へを押した時点で再入力を促される