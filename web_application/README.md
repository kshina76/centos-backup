# プロになるためのWeb技術入門

- アプリケーションの種類
    1. デスクトップアプリケーション
        - 主な処理は手元のPC上で行われる
        - 画面はOSの機能を利用して表示されている
        - アプリケーションをPCにインストールする必要がある
        - インストールされたPC上でのみ動作する
        - 特にiPhoneやandroidやタブレットにインストールして使用するアプリケーションをネイティブアプリという
    2. Webアプリケーション
        - 主な処理はサーバ上で行われる
        - 画面はブラウザの機能を利用して表示される
        - インストールが不要

- フロントエンド、バックエンド、インフラの領域

![2020-10-28 3 30のイメージ](https://user-images.githubusercontent.com/53253817/97445033-23a54f80-1970-11eb-8560-7d5752757907.jpeg)

- アプリケーションで使われる技術

![2020-10-28 3 30のイメージ](https://user-images.githubusercontent.com/53253817/97444862-f48ede00-196f-11eb-94d5-85c129fb6c27.jpeg)

- ミドルウェアで使われる技術

![2020-10-28 3 31のイメージ](https://user-images.githubusercontent.com/53253817/97444915-02dcfa00-1970-11eb-915a-1f70085b1435.jpeg)

---

- Webが発展した歴史
    - Webとは
        - WWW(World-Wide-Web)を略した名称がweb
    
    - インターネットとは
        - 世界中のコンピュータが相互に通信できるようにしたネットワーク網
    
    - WWWとは
        - インターネットを使って情報共有するための仕組み
        - CERNという研究所が研究成果をHTMLで記述することで、研究の文献などをハイパーリンクで辿って、情報共有できるようにした
            - ハイパーリンクで辿れることが「蜘蛛の巣」のように見えることからWWWと名付けられた

        ![https---qiita-image-store s3 amazonaws com-0-186009-87a973b5-5a1a-bac6-b237-34cd383e3126](https://user-images.githubusercontent.com/53253817/97443711-b0e7a480-196e-11eb-8df8-a869bd41c726.png)

    - NCSA Mosaic
        - 画像の配置やグラフィカルな見た目を表示できるブラウザ
        - WWWが登場した当初のブラウザは色や画像などを表示することができなかったことから生まれた
        - このブラウザが改良されてIEやFirefoxなどが開発された
        - この頃では、まだ静的コンテンツを提供することしかできなかった
    
    - CGI
        - webサーバとバックエンドのプログラムの間でリクエストとレスポンスをやりとりするための規約
        - 動的コンテンツをユーザに提供するために誕生した
        - クライアントから渡されたリクエストをCGIからプログラムに送って、プログラムが動的コンテンツのHTMLを生成して返し、そのレスポンスをCGIが受け取って、Webサーバに渡して、webサーバからクライアントにHTMLが返ってくる
        - プログラムはPerlやCが使われていた
            - CGI=perlは間違いで、CGIが普及していた時にバックエンドのプログラムとして活躍していた言語がPerlということ
        - CGIの問題点
            1. Perlは簡単なテキスト処理はできるけど、大規模なシステムには不向きな言語。オブジェクト指向もない
            2. Webブラウザからリクエストが届くたびにプロセス(perlインタプリタ)を起動させていたから、速度が遅かった
                - リクエストが届くたびに起動して終了するという使い捨てのプロセスだから時間がかかる
                - webページにアクセスしても画面が表示されるのに時間がかかった

        ![https---qiita-image-store s3 amazonaws com-0-186009-a920ed81-be85-607e-9c9c-86ac4852673a](https://user-images.githubusercontent.com/53253817/97443729-b513c200-196e-11eb-98bb-f1e66c1ba096.png)

    - Java/サーブレット
        - CGIの問題点を解決するために登場した
        - サーブレットのCGIと違うところが、Webサーバと同じコンピュータ内で**常時プロセスを起動**して動的にコンテンツを生成することができたから速度が速かった
        - Javaもオブジェクト指向を装備していたことでweb開発で使われるようになった
        - JavaVMのおかげで、異なるプラットフォームでも同じものを動作させることができた
            - linuxやwindowsやiosのどこでも同じものを動かすことができた
        - サーブレットの問題点
            - Javaの出力命令を使ってHTMLを出力するから、プログラムが書きにくい

        ![https---qiita-image-store s3 amazonaws com-0-186009-2b9f38a9-96ad-c22f-ad95-9ec3ef16cc0d](https://user-images.githubusercontent.com/53253817/97443761-be9d2a00-196e-11eb-8cc1-f287abb30f5e.png)


    - JSP
        - HTMLにJavaのコードを埋め込むことを可能にした
            - <% %>で囲むと埋め込める
        - サーブレットはJavaのコード内にHTMLを埋め込んでいたが、その逆の発想
    
    - Webアプリケーションフレームワーク
        - サーブレットやJSPを一から作るのは大変
        - 機能をまとめたライブラリが登場して、さらに発展することでフレームワークが登場した
        - これによってさらに開発が楽になった

---


- URL(Uniform Resource Locator)
    - インターネット上のコンテンツを一意に指定するための仕組み

    - 「http://www.littleforest.jp/webtext/index.html」 の構造
        - スキーム名
            - リソースを取得するための方法
            - 「http」にあたる部分
            - 他にもmailto, ftp, file といったスキームが存在する
        - ホスト名
            - リソースが存在するホスト(コンピュータ)名を表している
                - 処理した結果を返すようなコンピュータをホストコンピュータという
            - 「www.littleforest.jp」に当たる部分
                - wwwは「ローカル名」といい、wwwサーバというコンピュータを表す
                - littleforest.jpは「親ドメイン名」といい、日本(jp)のlittleforestという組織を表す
        - パス名
            - webtext/index.htmlに当たる部分。コンピュータ上のリソースの位置
    
    - URI
        - URLとURNの総称のこと
            - URNは現在だとあまり使われていないため、ほぼURI=URLだと思っていい
    
---

- HTTPでは一回で一つのリソースを取得
    - imgタグで囲まれたHTMLが搭載されたWebページにアクセスすると、なぜかHTMLのリクエストをした後にimgタグの分だけ何回もリクエストが送られる
        - これはHTTPでは一回で一つのリソースを取得することから、このような動作になる

---

- ファイル名を省略したリクエスト
    - Webサーバの昨日で、デフォルトのページを設定することができる
        - 大抵index.htmlなどにアクセスするようになっている
    - 「http://gihyo.jp/」のようにファイルのパスが省略されているのは、この機能を使っている

---

- TCP/IP
    - IPアドレスを頼りに情報を届けるプロトコル
    - ブラウザから受け取ったHTTPリクエストなどの情報をパケットという単位に分割して送信して、受信側で組み立て直す
        - この動作をTCP/IPが責任を持って行っている
    - アプリケーション層のプロトコルは全てTCP/IPの上で成り立っていて、宛先のコンピュータを指定するためにIPアドレスを使用する
        - HTTP, SMTP, POP3, FTP, telnet, sshなど
    - TCP/IPがどのタイプのアプリケーションを処理するかはポート番号によって識別される
        - よく使われるポート番号はウェルノウンポートと呼ばれる
---

- グローバルIPアドレス
    - 身近で使用しているグローバルIPアドレスは「動的なIPアドレス」といって、モデムやルータの電源を入れ直した時や、定期的に変更される
        - 変更されるタイミングはISP(インターネットサービスプロバイダ)による
    - プロバイダとの契約によっては固定IPを割り振ることもできる

- グローバルIPアドレスから住所などが特定される危険性
    - グローバルIPから直接逆引きするのは難しい
        - 国とか地域ぐらいしかわからない
        - 地域に関しては、少し離れた市町村が表示されたり
    - 逆引きして大まかな位置を絞って、SNSなどを使って特定することは可能
        - https://pc-pier.com/blog/2020/03/18/get-identified/
        - こういうので有名人の匿名掲示板への書き込みがバレたりするのかな

---

- 自由に使用していいプライベートIPアドレス
    - 10.0.0.0 ~ 10.255.255.255
        - クラスA
            - 利用可能な個数 : 16,777,216個
    - 172.16.0.0 ~ 172.31.255.255
        - クラスB
            - 利用可能な個数 : 1,048,576個
    - 192.168.0.0 ~ 192.168.255.255
        - クラスC
            - 利用可能な個数 : 65,536個
    - 通常はそんなにLAN内で接続するコンピュータの数は多くないので、クラスCで設定されていることが多い
    - 自分の大学だと、まあまあコンピュータがあるからクラスBの範囲で指定されているのだと思う

---

- DNS
    - ドメイン名をIPアドレスに変換する機能
    - ドメインを一つのサーバで管理するのは大変なので、「.」区切りで木構造のように管理されている
        - DNSサーバの大元はルートDNSサーバといって、「jp」や「com」といったドメインが登録されている
            - その下に色々なドメインが木構造で登録されていく
            - 「jp」や「com」などをTLD(トップレベルドメイン)という
    - 例えば、「http://www.littleforest.jp/webtext/index.html」のドメインのlittleforest.jpをDNSサーバで管理したら
        - ルートDNSサーバにjpが登録されている->jpドメインのDNSサーバ->jpドメインのDNSサーバにlittleforestが登録されている->名前解決
            - このように辿って行きながら名前解決される

---

- GETメソッドによるパラメータ渡し
    - HTMLのformでGETを指定してもパラメータを渡すことができる
    - クライアントからformに入力してsubmitすると、クエリ文字列としてURLにパラメータが載せられてサーバにリクエストされる
    - リクエストを取得して覗いてみると、一行目のリクエストラインにクエリ文字列が並んでいる
    - 問題点
        - GETメソッドでパラメータを渡してしまうと、大事な情報でもURLに記述されるため、傍受されていたら第三者に情報が渡ってしまう

- POSTメソッドによるパラメータ渡し
    - HTMLのformでPOSTを指定するよく使われるやり方
    - POSTで行うと、クエリ文字列としてURLに記述されないで、リクエストのメッセージボディに変数と値が記述されるようになる
    - この方法だとURLから推測されない。
    - メッセージボディのものはwebサーバのログに残ることは少ない。技術的には可能だが、膨大になるため残さない
        - 残る可能性もあるため、セキュリティには注意を払う必要がある

- GETとPOSTの使い分け
    - ログインや決済やformの内容が長すぎる際はPOSTを使うべき
        - 「副作用がある」というように表現される
        - URLは文字数制限がある
    - 外に渡っても問題ない情報や短いformの場合はGETを使う
        - 例えば、amazon内での商品の検索結果など
            - このような場合には積極的に利用する。なぜなら商品の検索結果を友達に送る際などにURLを送るだけでそのページを参照できるから

    ![ec625236-19b5-a265-69a1-1dbd0aab7e18](https://user-images.githubusercontent.com/53253817/97304339-ede46600-189e-11eb-8716-e46fd5eb6c8b.png)


- パーセントエンコード
    - 文字列を16進数の文字コードで表したもの
    - 日本語や空白といった文字列をクエリ文字列として渡すには、パーセントエンコードする必要がある
    - この処理はブラウザ側で自動的に行われる

---

- FTPはステートフルなプロトコル、HTTPはステートレスなプロトコル
    - ステートレスなHTTPプロトコルで状態を保持するにはCookieを使う
    - ログイン認証などにはログインしているという状態を保持しなければいけないので、Cookieが使われる
        - 単純にformでPOSTで認証情報送って判定するだけのプログラムだと、状態が保持されないので、毎回入力してログインしなければいけないという手間が発生する

- Cookie
    - ステートレスなプロトコルに情報を持たせるための技術
    - レスポンスヘッダのSet-Cookieで設定できる
    - 手順
        1. webサーバからwebブラウザにHTTPレスポンスのヘッダを利用して小さい情報を送る(この仕組みをCookieという)
        2. webブラウザが次回同じwebサーバにアクセスする際に、受け取ったCookieをそのままHTTPリクエストのヘッダに入れて送る
        3. webアプリケーションは、リクエストヘッダに入っているCookieを調べることで誰がログインしてきたかを知ることができる
    - ログイン認証の実装の場合、ログアウトが押されたあとは、Cookieを送らないように削除する仕組みが必要

- Session(セッション)
    - セッションの仕組み
        - webページに訪れたユーザにセッションIDを付与して、そのユーザの色々な情報をwebサーバにファイルとして保存する
        - セッションIDをCookieでクライアントに送ってブラウザに保存しておいてもらう
            - これによって直接パスワードを送るわけではないので、危険性はある程度下がる
        - ブラウザを閉じるまでそのセッションIDが有効となって、ユーザの色々な情報をやり取りできる

    - Cookieの問題点
        - Cookieはリクエストヘッダやレスポンスヘッダに書き込まれてしまうため、パスワードなどを送るのはセキュリティ的に危険
        - Cookieは保持できる情報の量に制限がある

    - Webページにアクセスしてから退出するまでを1セッションとしてカウントする(Webブラウザを閉じるまで保存するとも言われている)

    - リンクなどを貼ってページを移動しても内容を保持できる

    - ショッピングサイトを例に説明
        - 「このユーザはだれか」はセッションIDで識別
        - 「なにを買ったか」はセッション変数にデータをセットして、セッションが持続する間保持できる
        - ショッピングサイトを移動するときはセッション情報を逐次取り出して、表示、移動する
        - 商品を追加した時はセッション変数に追加して、カートから削除した時はセッション変数から削除

- 認証の種類
    - フォーム認証
        - webアプリケーションで認証の判定をする。HTMLでフォームを作って認証するため、この名前がついている
    - Basic認証
        - Webサーバによって認証が提供されるため、プログラムを組まなくてもブラウザの設定で実現できる。しかし、平文でパスワードが送信されてしまったら、セッション情報は保存できないので、そのリスクが考慮できるのなら導入する
     - Digest認証

---

- CGIなどの図を2つ
    - P130,131

- CRUDとは
    - データベースに対する操作のこと
    - CRUDを実装すると言われたら、データベースに対する操作をwebアプリケーションで実現するということ

- データベースを操作する2つの方法
    - データベースクライアント
        - データベースのソフトウェアに同梱されているクライアントを使って人間が手作業でデータベースを操作する
    - webアプリケーションから操作
        - プログラムを組んでおけば自動で行ってくれる。CRUDの実装とかがこれに当たるかな

- データベースの構築場所
    1. Webサーバと同じコンピュータで構築
        - 小規模なシステムならこれで問題ない
        - 一つのコンピュータで複数のプロセスを動かすことになるので、リソースが足りなくなる可能性がある
    2. 別のコンピュータで構築
        - DBサーバを立てるということ
        - DBサーバを既存のシステムにも繋いだりといった柔軟性が上がる
        - 他のプロセスにリソースが食われる心配がなくなる
        - Web3層モデルと呼ばれる
            - 「Webサーバ、APサーバ、DBサーバ」の三つにコンピュータを分ける
        
        ![https---qiita-image-store s3 amazonaws com-0-186009-b24f661a-dd41-360a-8c09-e13e9edff6a1](https://user-images.githubusercontent.com/53253817/97443814-cceb4600-196e-11eb-82ce-1cf5934f47cd.png)

---

- WebサーバとAPサーバの通信方法
    - コンピュータ同士が通信するので、何かしらのプロトコルを使用しないといけない
    - TomcatというAPサーバのソフトウェアには、AJPプロトコルという独自のプロトコルが使われる
        - Apacheとの通信にはmod_jkというモジュールを使ってAJPプロトコルを使用している
            - 具体的な手順
                1. Apacheに届いたHTTPリクエストをmod＿jkがTomcatに転送して
                2. Tomcatがその上で動くWebアプリケーションに渡す
                3. Webアプリケーションが結果をTomcatに返す
                4. Tomcatがmod_jkに返す
                5. クライアントにHTTPレスポンスが届く
        - 扱うものがHTTPリクエストなのになぜHTTPのプロトコルを使用しないのか？
            - AJPを使ったほうが高速で通信できるかららしい

- WebサーバとAPサーバの分担
    - 静的コンテンツはWebサーバ
        - ApacheとかNginxとか
        - 一つあたりのリクエストの処理は軽い
        - リクエストが来る回数は多い
            - 一つの静的コンテンツの中にも画像やHTMLなどといった、一回のリクエストでは終わることができないことがわかる
    - 動的コンテンツを生成するためのWebアプリケーションはAPサーバ
        - 一つあたりのリクエストの処理は重い
        - リクエストが来る回数は少ない

- URLによってリクエストを振り分ける
    1. URLでindex.htmlが指定されていたら、APサーバには送らないでWebサーバでリクエストを処理する
    2. URLでindex.html以外が指定されていたら、APサーバにリクエストを流す
        - ここでAPサーバを複数用意した場合、URLごとに違うAPサーバにリクエストを流すといったこともできる
            - ロードバランサ的な
            - 大抵どのwebサーバのアプリケーションの設定も同じような設定だと思う

![https---qiita-image-store s3 amazonaws com-0-186009-7bb864f8-802e-b813-bff0-edc08fbeffb9](https://user-images.githubusercontent.com/53253817/97452153-ca411e80-1977-11eb-88cd-ef96b4b6644d.png)

![https---qiita-image-store s3 amazonaws com-0-186009-9654e297-7ffc-7064-f76b-e91537b94441](https://user-images.githubusercontent.com/53253817/97452173-ce6d3c00-1977-11eb-8109-afc7e361579e.png)

- 構成の使い分け(P161~164を見てまとめる。画像はスキャンして載せる)
    - 開発環境や小規模なWebサービス
        - Webサーバ一つでWebサーバとAPサーバの機能を使う
            - ApacheといったWebサーバの機能を使わないでAPサーバに同梱している最低限のWebサーバの機能で済ませるということ
    
    - 中規模以上のWebサービスの本番運用
        - WebサーバにApacheやNginxを使う
            - APサーバに同梱しているWebサーバの機能だけだと非力
        
        ![https---qiita-image-store s3 amazonaws com-0-186009-9654e297-7ffc-7064-f76b-e91537b94441](https://user-images.githubusercontent.com/53253817/97454339-feb5da00-1979-11eb-807c-9d9720140c04.png)


---

- リダイレクトとフォワードの違い
    - リダイレクト
        - 複数のリクエストとレスポンスが行われるから速度が遅い
        - URLが変わる
        - サーバ移転した時やログイン後の画面遷移とか？

        ![redirect](https://user-images.githubusercontent.com/53253817/97532332-79720a00-19f9-11eb-9932-9a023a95ae09.png)

    - フォワード
        - 一回のリクエストとレスポンスで行われるから速度が速い
        - URLが変わらない

        ![forward](https://user-images.githubusercontent.com/53253817/97532340-7d059100-19f9-11eb-9958-ab5092a88688.png)

    - 例
        - http://myite.com/hoge へのリクエストが来た時にhttp://mysite.com/fuga へ遷移させるのがリダイレクト
        - http://myite.com/hoge へのリクエストが来た時にhttp://mysite.com/fuga の情報を返すけど、URLは変わらずにhogeにするのがフォワード
        - http://mysite.com/fuga へのリクエストが来た時にそのままhttp://mysite.com/fuga の情報を返すのはどちらでもなくただのレンダリング
        - https://k-sasaking.net/programing/redirect-forwad/

- リクエストスコープ
    - フォワード元とフォワード先で情報を共有する仕組み
    - 一つのHTTPリクエストを処理する間だけ有効なので、リダイレクトのような複数のリクエストにまたがると共有できない

- セッションタイムアウト
    - セッションは記憶し続けてしまうとメモリ不足に陥ってしまうため、ユーザがセッション情報を最後に使用した時刻を記述しておいて、一定時間利用されなかった場合にセッションを破棄する機能がある
        - Tomcatのデフォルトは30分
        - 個人情報を入力するようなフォームでも時間が経ってしまうとタイムアウトになるやつもそうかな？

- セッションスコープとリクエストスコープのまとめ
    - セッションスコープ
        - リクエストをまたいでも情報を保持できる
        - メモリを無駄にしないようにセッションタイムアウトという機能がAPサーバにある
        - セッションの情報はAPサーバで制御する
        - セッションタイムアウトはWebサーバで制御する
        - ログインしているという情報やショッピングカートの中身の情報を持つ時などに使う
    - リクエストスコープ
        - 一つのリクエストを処理する間だけ情報を保持することができる
        - メモリを有効に使うことができる

    - P181の画像
    - P182の画像

- Cookieが拒否されている場合のセッションIDの受け渡し
    - URLリライティングという仕組みを使う

---

- アーキテクチャ
    - サーブレットとJSPはロジックとデザインを分離するために生まれた
        - サーブレットがログインのバリデーションといったロジック部分
        - JSPが画面表示といったデザインの部分
        - ロジックはバックエンドエンジニアが担当して、デザインをデザイナーが担当するといった分業が用意になる

    - MVCモデルの誕生
        - アプリケーションをModel,View,Controllerの三つに役割を分ける
        - Model
            - アプリケーションの「ロジックに関する部分」と「データの保持」を担当する
                - アプリケーション固有のロジックのことをビジネスロジックという
            - ロジックの結果のデータも自分自身(実際にはデータベース)に保存する
            - 画面に対する入出力の部分には一切関わらない
            - 担当する処理の例
                - ログイン処理
                - 商品一覧をデータベースから取得する処理
                - ユーザが選択した商品をショッピングカートに保存する処理
                - 商品の合計金額を計算する処理
        - View
            - アプリケーションの「モデルの処理結果の画面表示」を担当する
            - ロジックの部分には一切関わらない
            - 担当する処理の例
                - HTML生成
        
        - Controller
            - 「画面からの情報入力」と「Modelの呼び出しとその結果に従ったViewの呼び出し」を担当する
                - Modelの結果に従ったというのは、Modelからステータスが返されるから、それに従うということ。処理の結果の内容が返されるわけではない
            - 全体の流れを制御する役割
        
        - 注意点
            - DjangoのMVTモデルだと少し違う
                - URLディスパッチャ
                    - Viewの呼び出し
                - ModelをControllerではなくてViewが呼び出している
        
        - 気になったこと
            - Viewにロジックを書いて、Modelにはデータベースの定義だけ書いているプロジェクトがあるがこれはどうなのか？？

- アーキテクチャパターン
    - MVCモデルはアーキテクチャパターンのうちの一つ
        - 色々なアーキテクチャパターンが存在している
        - 他にはlayers(レイヤーパターン)というアーキテクチャパターンがあり、アプリケーションの処理を3つの層に分けて考える
            - プレゼンテーション層
                - システム利用者とシステムの橋渡し(インタフェース)の役割を行う
                - ユーザからの入力を受け付けて下位層のビジネスロジック層に渡して、その結果をブラウザに表示したりする
                - MVCを割り当てるとVとCがこの層に当たる
            - ビジネスロジック層
                - プレゼンテーション層からデータを受け取り、必要に応じてデータアクセス層を通じてデータベースを利用し、結果をプレゼンテーション層に返す
                - データベースにアクセスするためのSQL文とかはここでは書かないで、次の層にお願いする
                - MVCを割り当てるとMが当たる
            - データアクセス層
                - ビジネスロジック層とデータベースの仲立ちをする役割
                - 実際にSQLなどでデータベースにアクセスする処理をビジネスロジック層から分離させるために存在している
                - データベースにアクセスするクラスを用意して、ビジネスロジック層から呼び出せるようにしておく
                - データアクセス層の実現方法はDAOと呼ばれている
            - 実際の設計方法としては、それぞれの層を独立したクラスとして用意して、それぞれの層は隣接する層だけを扱うようにすればいい

            ![bizappbasic02_02](https://user-images.githubusercontent.com/53253817/97544382-dd51fe00-1a0c-11eb-899f-2d867cd1437c.gif)

- O/Rマッピング(ORM, オブジェクト関係マッピング)
    - SQLを簡単に実行できるようにした構文
        - DjangoでもORMとして実装されている
    - データアクセス層でSQLを使ったアクセスをさらに簡易化してコードを見やすくするために使われる

- フレームワークを利用するメリット、デメリット
    - メリット
        - 設計、開発工数の削減
        - 品質の向上
        - テスト工数の削減
    - デメリット
        - 学習コストの増大
        - 設計における自由度の低下
        - 長期的な技術力の低下

---

- Webアプリケーションが守らなければいけないセキュリティ
    1. 第三者への情報の流出を防ぐこと（機密性）
    2. 第三者による情報の改ざんを防ぐこと（完全性）
    3. 適切な権限を持った人間が適切な情報を利用できること（可用性）

- 代表的なWebアプリケーションの攻撃手法
    - SQLインジェクション
        - 手法

        - 対策
            - 入力値のチェック
                - この攻撃で使われる文字を使えないようにする「'」という文字を弾くとか
            - プリペアードステートメントの利用
    - クロスサイトスクリプティング（XSS）
        - 手法

        - 対策
            - サニタイジング
                - まずは入力値のチェックを行ってから、それをパスしたものに対してサニタイジングを行うのがいい
    - セッションハイジャック
        - 意味と手法
            - セッションIDが盗まれて、そのセッションIDでアクセスがされることによって個人情報が取られてしまう

        - 対策（以下の対策を全て行う）
            - クロスサイトスクリプティング（XSS）の対策
            - 通信経路の暗号化
                - SSLを使って暗号化することでtcpdumpなどで盗聴されないようになる
            - セッションタイムアウトの値の変更
                - タイムアウトを短くすることで、第三者にセッションIDが盗まれても被害を少なくできる
                - ただし、短くしすぎると操作性が損なわれてしまう
            - セッションIDのランダム化
                - 1,2,3...のような推測しやすいセッションIDが発行されないようにする
                - これに関してはAPサーバが自動的に行ってくれるため、考えなくていい

    - クロスサイトリクエストフォージェリ（CSRF）
        - 手法
            - 捏造したフォームから強制的に情報をサブミットする手法

        - 対策
            - ワンタイムトークンを使って防ぐ

    - 強制ブラウズ
        - 手法
            - ログインしないと見れないページのURLを推測して、直接そのURLを入力することでアクセスすること
        - 対策
            - どのような画面にアクセスされたとしても、Cookieとセッションを使ってログイン状態をチェックするようにする

    - ディレクトリトラバーサル
        - 手法
            - ヌルバイト攻撃

        - 対策

- 設計ミスによる誤作動やセキュリティ問題を防ぐ処置
    - 戻るボタン対策
        - 問題
            - ブラウザには「キャッシュ」といって一度表示したページを保存しておく機能がある
            - 例えば、注文した後に戻るボタンを押すとキャッシュから前のページの情報が読み込まれて、再度注文できるようになってしまう
                - 戻るボタンは、再度リクエストを送らないでキャッシュからページを取得できてしまうから
        - 対策
            - ブラウザによるキャッシュの無効化
                - HTMLの機能だが、フレームワークの機能にあることが多いので、まずはそっちを確認する
            - 戻るボタンの無効化
                - JavaScriptで実現するが、ブラウザでJavaScriptは向こうにできてしまうから有効な方法ではない
            - ワンタイムトークンの利用 
                - 注文と同時にワンタイムトークンを送信すると、戻るボタンで再度注文しようとしてもワンタイムトークンに対する注文は蚊完了しているから、注文は弾かれる
    - ダブルサブミット対策
        - 問題
            - ユーザがサーバが混雑している時にボタンが反応しないからといって何回も注文ボタンを押してしまうことで、複数の注文がされてしまうこと
        - 対策（二つの方法が実装されていると良い）
            - JavaScriptを使った対策
                - 押されたかどうかの判定をして、押されたら常にtrueとなる関数を作成する
            - ワンタイムトークンによる対策
                - 戻るボタンの時と同じように判定する

- hiddenパラメータ利用の注意点
    - hiddenパラメータを送る人が本当に本人かどうかをワンタイムトークンで確認するようにする

- デバッグ情報を画面に表示しない
    - ログはサーバの中の決められたファイルに出力して保存するといった対処をする
    - 404 not foundの時にステータスコードだけ表示して、エラーの内容は表示しないということ

- グローバル変数やクラス変数に意味を持たせない
    - セッションスコープやリクエストスコープを利用して対処する

---


# Webアプリケーション開発の手順
- 要求分析
    - お客さんの仕事の流れなどから、どのようなことをしたいのか、どんなシステムだと現状の問題を解決できるのかということを分析する
- 画面遷移図
    - UIの遷移をスケッチする
    - 例えば、ログイン画面の遷移図なら、ログインに成功した場合はどのような画面になるのか、失敗したらどのような画面になるのかというスケッチ
- 画面モックを作る
    - HTMLとCSSのみで作られたハリボテのサイト
        - 遷移先の画面なども含めて
        - リンクやロジックは実装していないので、URLから直接入力して画面を確認する
    - このフェーズではバックエンドなどの実装は行わなくていい
    - お客さんにプロトタイプを見せるために
- 実際のロジックの作成(例えば、ログインの認証機能など)
    - 機能を実装したら一つ一つ動作を確認するようにする

# 気になること
- 任意のサイトにリクエストを送って、HTTPリクエストとレスポンスを取得して表示してみる
    - windowsだと「横取り丸」と「Inetspy」を使うとできるが、go言語とかでサーバ立てて取得すればいい気がする
- プログラミング言語ごとの特徴と作れるもの
    - https://www.youtube.com/watch?v=HUZlOEbSP6c

# わかったこと
- Webアプリ開発においては、とにかくパクる
    - フロントエンドやバックエンドなどはフレームワークを使って作る
    - CSSやHTMLはbootstrapを使う
    - 画像認識の機能をつけたいならGoogleの画像認識AIのAPIを使う

---

- 帯域幅とは

---

- クラウドネイティブとは
    - クラウドを使ったシステムを構築することを優先すること

---

- Webサーバとは
    - クライアントからのリクエストに対して、「静的コンテンツを見せること」と「APサーバに動的コンテンツを要求し、返ってきた結果を見せること」という二つの役割がある。
        - 大体はWebアプリケーションサーバとして、WebサーバとAPサーバをまとめて一つのサーバとされることが多い。
            - go言語に関して説明すると、静的コンテンツと動的コンテンツの切り替えはマルチプレクサが行って、動的コンテンツの生成はハンドラとテンプレートエンジンによって行われていることから、WebサーバとAPサーバどちらの機能も一つとしてまとめられていることがわかる。
    - 静的コンテンツはWebサーバのディスクに保存される
    - 他の用途としては、リバースプロキシとして使われる

- APサーバとは
    - goなどを使ったプログラムを実行して動的コンテンツを生成するサーバ
    - DBサーバにリクエストを送ってテンプレートとデータを混ぜてHTMLを生成する機能を持ったサーバ
    - よく開発している部分は厳密にはwebサーバでなくてAPサーバの部分だと思う

---

- どの種類のサーバに繋ぐときも同じ手順(コンピュータ同士が通信する時はいつも。コンピュータというより別のプロセス同士かな？)
    1. listenするipアドレスとポート番号を使うソフトウェアのconfファイルなどで設定
        - DBサーバを立てたくて、ソフトウェアはPostgresqlを使うならpostgresql.confというファイルでlisten_addressとpostという欄を設定する
        - 大抵は、デフォルトだとlocalhostからの接続しか受け付けていないので、注意する
    2. 1で設定したポートをサーバの設定で開く
        - Postgresqlの設定ではなくて、載せているサーバ自体のファイアウォールの設定。ufwとか。
        - AWSを使うならEC2上で設定する
    3. 後は接続するだけ
        - go言語などのプログラミング言語を使ってDBサーバにアクセスしたい場合、ライブラリを入れるかフレームワークの機能を使って接続する

---

- データベースのプロトコルって何を使っているの？
    - NginxやApacheはTCP/IP4階層モデルのアプリケーション層で動くHTTPというプロトコルを使用している
    - データベースは独自のプロトコルで動作している
        - HTTPやFTPといった既存のプロトコルを使用しているわけではない
        - 例えば、MySQLはTCP/IP4階層モデルのアプリケーション層で動くMySQLプロトコルというものを使用している
            - やはりTCP/IPで動作するものなのでIPアドレスとポート番号を指定すると接続できる

- TCP/IP4階層モデルでIPアドレスとポート番号を指定している理由
    - トランスポート層ではポート番号を指定することで、アプリケーション層からもらったデータを宛先のアプリケーション層に届ける使命がある
        - ここではIPアドレスは関係ない
    - インターネット層ではIPアドレスを指定することで、データを宛先のコンピュータに届ける使命がある
        - ここではIPアドレスを使って処理する
    - まとめると
        - ポート番号がどのような種類のアプリケーションかを判断するために使用している(80はhttpとか443はhttpsとか)
        - IPアドレスでインターネット上でのコンピュータの位置を判断するために使用している
        - 要は全ての層が連携をすることによって通信を可能にしている
            - 例えば、HTMLを取得したいときは、以下のようにプロトコルが選択されて連携する
                1. アプリケーション層からはHTTPを選択
                2. トランスポート層からはTCPを選択
                3. インターネット層からはIPを選択
                4. ネットワークインタフェース層からはEthernetを選択
    - 参考文献
        - https://qiita.com/genre/items/05186691fbf8c10a4a48

- TCP/IP上で成り立っているアプリケーションは全て通信することができる

---


# 参考文献
- プロになるためのWeb技術入門
- 上記の書籍のHTTPらへんをきれいにまとめているブログ
    - https://qiita.com/Sekky0905/items/dff3d0da059d6f5bfabf

- プロになるためのWeb技術入門のわかりやすい図
    - https://qiita.com/hththt/items/07136ad74127999df271

- https://thinkit.co.jp/article/11837
    - webサーバ,APサーバ,DBサーバの違い

- ログイン処理のアンチパターン
    - http://en.yummy.stripper.jp/?eid=987602