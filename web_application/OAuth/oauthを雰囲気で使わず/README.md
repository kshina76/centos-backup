# 書籍メモ
- 追加で見るべき本
  - OAuth1.0と2.0の違いについては技術書典7
  - OAuth2.0に関する攻撃手段については技術書典8
- 注意事項
  - この本ではOAuth1.0に関しては触れないから、OAuth=OAuth2.0として読んでいく
- OAuth1.0とOAuth2.0は認可のプロトコル
- OpenID Connectは認証と認可のプロトコル
## 第1章 はじめに
### OAuthとは
- 定義
  - OAuth2.0はサードパーティアプリケーションによるHTTPサービスへの限定的なアクセスを可能にする認可フレームワークである。
- 以下の図に沿った定義
  - OAuth2.0は「画像編集アプリによるGooglePhotoへの限定的なアクセス(Aさんの領域へのアップロードのみ)」を可能にするための「アクセストークンの発行方法のルール」である。

![2021-01-07 15 52のイメージ](https://user-images.githubusercontent.com/53253817/103861234-70d83700-5100-11eb-83ea-84a08feb0c4b.jpeg)

- OAuth2.0がRFCで定められている「アクセストークンの発行方法のルール」で、GoogleのOAuthサービスが「ルールに沿ってトークンを発行するサービス」
- GoogleフォトなどのAPIはそのトークンを見て許可された操作かどうかを判断する
### OAuthはなぜ必要か
- 1.OAuthを使えば、ユーザーはサードパーティアプリにHTTPサービスのユーザー名、パスワードを教える必要がない
### OAuthを使わないで、サードパーティにユーザー名、パスワードを教えると発生する問題
1. 画像編集アプリが悪意のある開発者が開発したものの場合、悪意のある開発者がGoogleフォトのユーザ名とパスワードが取得できてしまう
2. 1に気づいて、ユーザ名とパスワードを変更した場合、Aさんが利用する他のサードパーティアプリからもGoolgePhotoにアクセスできなくなってしまう
3. 画像編集アプリがユーザー名、パスワードを保持している場合、画像編集アプリが攻撃を受けるとユーザー名と、パスワードが漏洩してしまう可能性がある

<br></br>

## 第2章 OAuthのロール
### ロール
- リソースオーナー: リソースの所有者、クライアントアプリのユーザ
- クライアント: リソースサーバを利用するアプリケーション
- リソースサーバ: WebAPIのこと
- 認可サーバ: アクセストークンを発行するサーバ
### 処理の流れ
1. クライアントは認可サーバに対して「リソースへのアクセス権」を要求する
2. 認可サーバは「クライアントへのアクセス権の委譲」についてリソースオーナーの意思を確認する
3. リソースオーナーはアクセス権の委譲について同意する
4. 認可サーバはアクセス権が委譲された証(アクセストークン)を発行する
5. クライアントはアクセストークンを持ってリソースへのアクセスが可能になる

![2021-01-07 16 17のイメージ](https://user-images.githubusercontent.com/53253817/103863262-e09bf100-5103-11eb-94b8-d3b0f0a25f75.jpeg)

<br></br>

## 第3章 OAuthのトークン
- 全てのリクエストにトークンが含まれていないといけない(多分JSON内に)
### アクセストークン
- 利用される場所
  - クライアントからリソースサーバにアクセスする際に使用される
- アクセストークンに含まれる情報
  - 誰のどのリソースにどのような操作を行うことが許可されているか
  - 有効期限はいつまでか
- 使用するトークンの種類
  - Bearerトークン: リソースサーバはアクセストークンの送信元確認しないもの
- スコープ
  - 書き込み権限、シェア権限といった権限の範囲をコントロールするためのもの
  - スコープの指定は、クライアントから認可サーバーへのリクエストの際に行われる
- 有効期限
  - アクセストークンの有効期限
  - 有効期限はアクセストークンと取得する時のレスポンスボディの中に記載されている
### リフレッシュトークン
- 利用される場所
  - クライアントから認可サーバに対してアクセストークンの再発行を要求する際に利用される
- 必須ではないから、搭載していない場合もある
### 認可コード
- リソースオーナーがクライアントへの権限委譲に同意した証として、クライアントに対して認可サーバが発行するもの
- 認可コードを再度認可サーバに送信することで、アクセストークンを取得することができる
- 利用される場所
  - クライアントから認可サーバに対してアクセストークンを要求する際に利用される
- 有効期限は10分以内が推奨されている

<br></br>

## 第4章 OAuthのエンドポイント
- URIで提供されるエンドポイント
### 認可エンドポイント
- 認可サーバが提供するエンドポイント
- 用途
  - 認可コードの発行が主な役割
- 流れ
  - クライアントがリソースサーバへのアクセス権がない場合にアクセスする
  - 認可エンドポイントでユーザ名とパスワードの入力などによってリソースオーナーの認証が行われる
  - リソースオーナーがアクセス権の委譲に同意する
  - 認可コードがリダイレクトエンドポイントに送られる
### トークンエンドポイント
- 認可サーバが提供するエンドポイント
- 用途
  - アクセストークンを受け取るために使用される
- 流れ
  - 認可コードを受け取ったクライアントがそれと共に必要なパラメータと一緒にトークンエンドポイントに投げる
  - Basic認証でクライアントのアイデンティティが認証される
    - Basic認証では、クライアントIDとクライアントシークレットで認証される
    - クライアントIDとクライアントシークレットは、認可サーバにクライアントを事前登録する際に発行される
  - アクセストークンを取得
### リダイレクトエンドポイント
- クライアントが提供するエンドポイント
- 用途
  - 認可サーバから認可コードを受け取るために使用される
- 流れ
  - リソースオーナーの権限委譲の同意が行われる
  - 302を返してブラウザをリダイレクトエンドポイントにリダイレクト
  - その際に、クエリパラメータとして認可コードを受け取る(リダイレクトエンドポイントで受け取る)
- 例
  - リダイレクトエンドポイントが「https://client.example.com/callback」の場合以下のレスポンスが返ってくる

  ```
  HTTP1.1 302 FOUND
  Location: https://client.example.com/callback?code=SplxlOBeZQQYbYS6WxSbIA
  ```

<br></br>

## 第5章 OAuthのグラントタイプ
- グラントは「付与」という意味がある
- グラントタイプは「権限付与(委譲)のタイプ」という意味
### クライアント登録
- 全てのグラントタイプ(一つの例外をのぞいて)はクライアントの事前登録を行う必要がある
- リソースサーバを提供する組織の開発者向けサイトでクライアントを登録することで、「クライアントIDとクライアントシークレット」の発行をしてもらう
- 開発者がクライアントの情報として登録する最も大事なものは「リダイレクトエンドポイント」
### 認可コードグラント
- 用途
  - あらゆるタイプのクライアントに使われる
  - 単体で使用するならサーバサイドのウェブアプリケーションで使用する

### インプリシットグラント
- 用途
  - パブリッククライアント向け
  - クライアントサイドJavaScriptで実装されたアプリでの使用
  - ネイティブアプリケーションでの使用
- 非推奨なので、代わりに「認可コードグラント+PKCE」を使った認可コードグラントが使用される

### クライアントクレデンシャルグラント

### リソースオーナーパスワードクレデンシャルグラント

### リフレッシュトークンによるアクセストークン再発行

### 認可コードグラント + PKCE

<br></br>

## 付録A OAuth認証について
### OAuthは認証のプロトコルではない
- 使い分け
  - 「サードパーティアプリからGoogleのリソースサーバのデータにアクセス」: OAuth2.0
  - 「サードパーティアプリにGoogleアカウントでログイン」: 「OpenID Connect」または「OAuth2.0(認可コードグラント) + プロフィールAPI + debug_token」
- なぜOAuth認証と言われてしまうことがあるのか
  - OAuthは認可のプロトコルだが、認証にも使えてしまうため
  - FacebookやTwitterアカウントによる認証にOAuthが使われているから
- OAuthをそのまま使った認証は脆弱性があるので、OAuthを認証に使えるように拡張したものがOpenID Connect
### OAuth+プロフィールAPIを使った認証の仕組み
- インプリシットグラントによるOAuth認証: 脆弱性がある
- 認可コードグラント: debug_tokenと一緒に使えば脆弱性はなくなる(多分)
- ポイントB
  - 多くの人がここでユーザ名とパスワードを入力しているからユーザがクライアントに認証されると思い込んで、「OAuth認証」と言ってしまっている
  - 正しくは「リソースオーナーであることを確認するために認可サーバーが認証を行う」
  - この段階で決してクライアントにユーザが認証されているわけではない
- ポイントC
  - 本来はここで、ユーザがクライアントに認証される
  - クライアントはFacebookのユーザプロフィールをFacebookのリソースサーバから取得してきて、それをユーザ認証に使っている

![2021-01-07 22 25のイメージ](https://user-images.githubusercontent.com/53253817/103897800-65ecc900-5137-11eb-8247-0b232743b1fa.jpeg)

### 結論
- ログインなどの認証機能を実装したいならOpenID Connectベースのものを使う
- OAuthは認証ではなく認可！！

### Google OAuth2.0で認証
- OAuth2.0と書かれているのに認証ってどういうこと？？
  - Google OAuth2.0はOpenID Connectに準拠しているらしいので問題ない
  - Googleの命名があまりよくない気がするが、、
- https://qiita.com/toshihirock/items/6679c59ac050f1740db2
