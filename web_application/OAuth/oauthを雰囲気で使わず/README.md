# 書籍メモ
- 追加で見るべき本
  - OAuth1.0と2.0の違いについては技術書典7
  - OAuth2.0に関する攻撃手段については技術書典8
- 注意事項
  - この本ではOAuth1.0に関しては触れないから、OAuth=OAuth2.0として読んでいく
- OAuth1.0とOAuth2.0は認可のプロトコル
- OpenID Connectは認証と認可のプロトコル

## 第0章 自分メモ
### フローとクライアントタイプ
- コンフィデンシャルクライアント
  - クレデンシャルを安全に秘匿できるサーバーアプリケーション上でのOAuthクライアントとして利用されることを想定
- パブリッククライアント
  - iOS/AndroidアプリやJavaScriptなどの、クレデンシャルを安全に秘匿できないフロントエンドアプリケーション上でのOAuthクライアントとして利用されることを想定
- クレデンシャル
  - クライアントID、クライアントシークレットのこと
  - クライアントIDとクライアントシークレットを使用することでGoogleのAPIなどを叩くことができる
- 明示的に禁止されているのは、クライアントクレデンシャルズフローと Public クライアントの組み合わせだけ

  ![2021-01-12 0 44のイメージ](https://user-images.githubusercontent.com/53253817/104203427-71116300-546f-11eb-8158-da79823e70b3.jpeg)

<br></br>

## 第1章 はじめに
### OAuthとは
- 定義
  - OAuth2.0はサードパーティアプリケーションによるHTTPサービスへの限定的なアクセスを可能にする認可フレームワークである。
- 以下の図に沿った定義
  - OAuth2.0は「画像編集アプリによるGooglePhotoへの限定的なアクセス(Aさんの領域へのアップロードのみ)」を可能にするための「アクセストークンの発行方法のルール」である。

![2021-01-07 15 52のイメージ](https://user-images.githubusercontent.com/53253817/103861234-70d83700-5100-11eb-83ea-84a08feb0c4b.jpeg)

- OAuth2.0がRFCで定められている「アクセストークンの発行方法のルール」で、GoogleのOAuthサービスが「ルールに沿ってトークンを発行するサービス」
- GoogleフォトなどのAPIはそのトークンを見て許可された操作かどうかを判断する
### OAuthはなぜ必要か
- 1.OAuthを使えば、ユーザーはサードパーティアプリにHTTPサービスのユーザー名、パスワードを教える必要がない
### OAuthを使わないで、サードパーティにユーザー名、パスワードを教えると発生する問題
1. 画像編集アプリが悪意のある開発者が開発したものの場合、悪意のある開発者がGoogleフォトのユーザ名とパスワードが取得できてしまう
2. 1に気づいて、ユーザ名とパスワードを変更した場合、Aさんが利用する他のサードパーティアプリからもGoolgePhotoにアクセスできなくなってしまう
3. 画像編集アプリがユーザー名、パスワードを保持している場合、画像編集アプリが攻撃を受けるとユーザー名と、パスワードが漏洩してしまう可能性がある

<br></br>

## 第2章 OAuthのロール
### ロール
- リソースオーナー: リソースの所有者、クライアントアプリのユーザ
- クライアント: リソースサーバを利用するアプリケーション
- リソースサーバ: WebAPIのこと
- 認可サーバ: アクセストークンを発行するサーバ
### 処理の流れ
1. クライアントは認可サーバに対して「リソースへのアクセス権」を要求する
2. 認可サーバは「クライアントへのアクセス権の委譲」についてリソースオーナーの意思を確認する
3. リソースオーナーはアクセス権の委譲について同意する
4. 認可サーバはアクセス権が委譲された証(アクセストークン)を発行する
5. クライアントはアクセストークンを持ってリソースへのアクセスが可能になる

![2021-01-07 16 17のイメージ](https://user-images.githubusercontent.com/53253817/103863262-e09bf100-5103-11eb-94b8-d3b0f0a25f75.jpeg)

<br></br>

## 第3章 OAuthのトークン
- 全てのリクエストにトークンが含まれていないといけない(多分JSON内に)
### アクセストークン
- 利用される場所
  - クライアントからリソースサーバにアクセスする際に使用される
- アクセストークンに含まれる情報
  - 誰のどのリソースにどのような操作を行うことが許可されているか
  - 有効期限はいつまでか
- 使用するトークンの種類
  - Bearerトークン: リソースサーバはアクセストークンの送信元確認しないもの
- スコープ
  - 書き込み権限、シェア権限といった権限の範囲をコントロールするためのもの
  - スコープの指定は、クライアントから認可サーバーへのリクエストの際に行われる
- 有効期限
  - アクセストークンの有効期限
  - 有効期限はアクセストークンと取得する時のレスポンスボディの中に記載されている
### リフレッシュトークン
- 利用される場所
  - クライアントから認可サーバに対してアクセストークンの再発行を要求する際に利用される
- 必須ではないから、搭載していない場合もある
### 認可コード
- リソースオーナーがクライアントへの権限委譲に同意した証として、クライアントに対して認可サーバが発行するもの
- 認可コードを再度認可サーバに送信することで、アクセストークンを取得することができる
- 利用される場所
  - クライアントから認可サーバに対してアクセストークンを要求する際に利用される
- 有効期限は10分以内が推奨されている

<br></br>

## 第4章 OAuthのエンドポイント
- URIで提供されるエンドポイント
### 認可エンドポイント
- 認可サーバが提供するエンドポイント
- 用途
  - 認可コードの発行が主な役割
- 流れ
  - クライアントがリソースサーバへのアクセス権がない場合にアクセスする
  - 認可エンドポイントでユーザ名とパスワードの入力などによってリソースオーナーの認証が行われる
  - リソースオーナーがアクセス権の委譲に同意する
  - 認可コードがリダイレクトエンドポイントに送られる
### トークンエンドポイント
- 認可サーバが提供するエンドポイント
- 用途
  - アクセストークンを受け取るために使用される
- 流れ
  - 認可コードを受け取ったクライアントがそれと共に必要なパラメータと一緒にトークンエンドポイントに投げる
  - Basic認証でクライアントのアイデンティティが認証される
    - Basic認証では、クライアントIDとクライアントシークレットで認証される
    - クライアントIDとクライアントシークレットは、認可サーバにクライアントを事前登録する際に発行される
  - アクセストークンを取得
### リダイレクトエンドポイント
- クライアントが提供するエンドポイント
- 用途
  - 認可サーバから認可コードを受け取るために使用される
- 流れ
  - リソースオーナーの権限委譲の同意が行われる
  - 302を返してブラウザをリダイレクトエンドポイントにリダイレクト
  - その際に、クエリパラメータとして認可コードを受け取る(リダイレクトエンドポイントで受け取る)
- 例
  - リダイレクトエンドポイントが「https://client.example.com/callback」の場合以下のレスポンスが返ってくる

  ```
  HTTP1.1 302 FOUND
  Location: https://client.example.com/callback?code=SplxlOBeZQQYbYS6WxSbIA
  ```

<br></br>

## 第5章 OAuthのグラントタイプ
- グラントは「付与」という意味がある
- グラントタイプは「権限付与(委譲)のタイプ」という意味
### クライアント登録
- 全てのグラントタイプ(一つの例外をのぞいて)はクライアントの事前登録を行う必要がある
- リソースサーバを提供する組織の開発者向けサイトでクライアントを登録することで、「クライアントIDとクライアントシークレット」の発行をしてもらう
- 開発者がクライアントの情報として登録する最も大事なものは「リダイレクトエンドポイント」
### 認可コードグラント
- 用途
  - PKCEを使うことで、あらゆるタイプのクライアントに使われる
  - 単体で使用するならサーバサイドのウェブアプリケーションで使用する
- 特徴
  - リフレッシュトークン発行が可能なので、アクセストークンの有効期限が切れてもリソースオーナー認証を行わずに、新しいアクセストークンを取得することができる
- シーケンス図
  - 1: ユーザが「Google Photoから画像を取得」ボタンを押すことでOAuthがスタート
  - 2~3: Googleの認可サーバへのリダイレクトが実行される
    - GETリクエストで、クエリパラメータにいろいろな情報が付与される
  - 4: リソースオーナーにログイン画面を表示
  - 5: ユーザ名、パスワードを入力して認証が完了する
    - 二段階認証、顔認証、指紋認証などなんでもいい
  - 6: 3でクライアントが指定したスコープに沿って、権限の一覧を表示する
    - write権限とかread権限とか
  - 7: リソースオーナーが画面で同意をする
  - 8: 認可コード発行
  - 9: リソースオーナーのブラウザがリダイレクトURIにリダイレクトされる
    - リダイレクトURIのクエリパラメータに認可コードとstateが付与されている
  - 10: クライアントの認証がBasic認証で行われる
    - 認可コード、クライアントID、クライアントシークレットを送る
    - トークンリクエストと呼ぶ
  - 11: 「アクセストークン、リフレッシュトークン、トークンの有効期限」が渡される
    - トークンレスポンスと呼ぶ
  - 12: リソースにアクセス
    - リクエストのルールとしては、AuthorizationヘッダがBearerということだけ。あとはAPIの仕様に則る

  ![2021-01-12 1 11のイメージ](https://user-images.githubusercontent.com/53253817/104206679-2bef3000-5473-11eb-821b-d6313efd034b.jpeg)

### インプリシットグラント
- 用途
  - パブリッククライアント向け
  - クライアントサイドJavaScriptで実装されたアプリでの使用
  - ネイティブアプリケーションでの使用
- 特徴
  - クライアントから認可サーバのリクエストの中で、クライアントの認証が行われないのが特徴
    - なぜかというと、クライアントIDとクライアントシークレットを安全に保存することができないから
    - リクエストにクライアントIDは含まれるけど、クライアントシークレットは含まれない
    - 認可コードグラントの8~10の作業がいらないからシンプル
  - リフレッシュトークンの発行が禁止されている
    - 有効期限が切れたら、アクセストークン発行のシーケンスをやり直す必要がある
  - 非推奨なので、代わりに「認可コードグラント+PKCE」を使った認可コードグラントが使用される
- シーケンス図
  - 1: ユーザが「Google Photoから画像を取得」ボタンを押すことでOAuthがスタート
  - 2~3: Googleの認可サーバへのリダイレクトが実行される
    - GETリクエストで、クエリパラメータにいろいろな情報が付与される
  - 4: リソースオーナーにログイン画面を表示
  - 5: ユーザ名、パスワードを入力して認証が完了する
    - 二段階認証、顔認証、指紋認証などなんでもいい
  - 6: 3でクライアントが指定したスコープに沿って、権限の一覧を表示する
    - write権限とかread権限とか
  - 7: リソースオーナーが画面で同意をする
  - 8~9: リダイレクトを使ってクライアントにアクセストークンが渡される

  ![2021-01-12 1 57のイメージ](https://user-images.githubusercontent.com/53253817/104213305-7a9fc880-5479-11eb-9b45-20dc8375d457.jpeg)


### クライアントクレデンシャルグラント(2-legged OAuth)
- 特徴
  - クライアントと認可サーバだけのやりとりでアクセストークンを発行する
  - エンドユーザが登場しないので、アクセストークンの権限はエンドユーザ単位ではなく、クライアント単位
    - エンドユーザが登場しないので、エンドユーザのidとパスワードの認証がない
    - エンドユーザが登場しないので、権限の同意もない
- シーケンス図
  - トークンエンドポイントへの一度のリクエストでアクセストークンが発行される
  - 1: Basic認証が行われる
    - クライアントIDとクライアントシークレットの認証
    - スコープの指定
  - 2: JSONの形でアクセストークンをレスポンス

  ![2021-01-12 2 16のイメージ](https://user-images.githubusercontent.com/53253817/104215508-3235da00-547c-11eb-9426-902e92326c1d.jpeg)


### リソースオーナーパスワードクレデンシャルグラント
- 特徴
  - 全てのロールが登場する
  - リソースオーナーのユーザ名とパスワードがクライアントを通して認可サーバに送られる
  - リフレッシュトークンの発行は任意
  - クライアントタイプは「コンフィデンシャル」と「パブリック」の両方で利用可能
  - 認可エンドポイントは利用しない
    - リソースオーナーがクライアントにユーザ名とパスワードを入力するから
- 用途
  - リソースサーバおよび認可サーバとクライアントの提供元が同じ組織である場合
- シーケンス図
  - クライアントはリソースオーナーのユーザ名とパスワードを保存しないのが重要

  ![2021-01-12 2 24のイメージ](https://user-images.githubusercontent.com/53253817/104216492-7a093100-547d-11eb-9636-7d0a8e4e880f.jpeg)


### リフレッシュトークンによるアクセストークン再発行

- シーケンス図

  ![2021-01-12 2 28のイメージ](https://user-images.githubusercontent.com/53253817/104216743-cfddd900-547d-11eb-9a21-1178f4809f88.jpeg)


### 認可コードグラント + PKCE
- PKCEはピクシーと読む
- ややこしいので他を理解したら勉強し直す

<br></br>

## 付録A OAuth認証について
### OAuthは認証のプロトコルではない
- 使い分け
  - 「サードパーティアプリからGoogleのリソースサーバのデータにアクセス」: OAuth2.0
  - 「サードパーティアプリにGoogleアカウントでログイン」: 「OpenID Connect」または「OAuth2.0(認可コードグラント) + プロフィールAPI + debug_token」
- なぜOAuth認証と言われてしまうことがあるのか
  - OAuthは認可のプロトコルだが、認証にも使えてしまうため
  - FacebookやTwitterアカウントによる認証にOAuthが使われているから
- OAuthをそのまま使った認証は脆弱性があるので、OAuthを認証に使えるように拡張したものがOpenID Connect
### OAuth+プロフィールAPIを使った認証の仕組み
- インプリシットグラントによるOAuth認証: 脆弱性がある
- 認可コードグラント: debug_tokenと一緒に使えば脆弱性はなくなる(多分)
- ポイントB
  - 多くの人がここでユーザ名とパスワードを入力しているからユーザがクライアントに認証されると思い込んで、「OAuth認証」と言ってしまっている
  - 正しくは「リソースオーナーであることを確認するために認可サーバーが認証を行う」
  - この段階で決してクライアントにユーザが認証されているわけではない
- ポイントC
  - 本来はここで、ユーザがクライアントに認証される
  - クライアントはFacebookのユーザプロフィールをFacebookのリソースサーバから取得してきて、それをユーザ認証に使っている

![2021-01-07 22 25のイメージ](https://user-images.githubusercontent.com/53253817/103897800-65ecc900-5137-11eb-8247-0b232743b1fa.jpeg)

### 結論
- ログインなどの認証機能を実装したいならOpenID Connectベースのものを使う
- OAuthは認証ではなく認可！！

### Google OAuth2.0で認証
- OAuth2.0と書かれているのに認証ってどういうこと？？
  - Google OAuth2.0はOpenID Connectに準拠しているらしいので問題ない
  - Googleの命名があまりよくない気がするが、、
- https://qiita.com/toshihirock/items/6679c59ac050f1740db2
