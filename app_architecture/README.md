# アプリケーションーアーキテクチャのメモ

## 正しいMVCアーキテクチャの理解
- https://at-grandpa.hatenablog.jp/entry/2013/11/01/072636
- https://www.slideshare.net/MugeSo/mvc-14469802

## 3層アーキテクチャと層の詳細
- 3層アーキテクチャ
    - データアクセス
        - データアクセス層の役割は、ファイルや DB に対してデータを読み書きすること
        - ビジネスロジックをデータアクセスと切り離すというのは、保存先がファイルだろうと、RDB だろうと、ドキュメント DB だろうと、ビジネスロジックはそれを気にかけないように記述するということ
        - データアクセス層は、保存先の媒体によらず同じインタフェースをビジネスロジック層に対して提供して、保存先が変わってもデータアクセス層だけ直せばいいというのが理想的
    
    - プレゼンテーション
        - プレゼンテーション層とは、そのアプリケーションとユーザ (またはクライアントプログラムなど) とのやりとりを担当する層
        - 古典的なMVCフレームワークによるWebアプリと同様の処理をAPIやCLIアプリケーションとして提供するとき、プレゼンテーション層以外が使い回せるような構造になっていると理想的。その使い回すべき部分のうち、データアクセスではない部分がビジネスロジック。
        - プレゼンテーション層の例
            - 古典的な MVC フレームワークの場合 ... View や Controller
            - API の場合 ... API を受け付ける Controller・リクエストやレスポンスの型
            - CLI アプリケーションの場合 ... コマンドラインオプションの解析・ユーザからの入力受付・処理結果の出力
    
    - ビジネスロジック
        - アプリケーションをプレゼンテーション・ビジネスロジック・データアクセスの 3 つに分けたとき、「プレゼンテーションでもデータアクセスでもない部分がビジネスロジック」
            - MVCアーキテクチャにおいてORMを使った場合、Modelそのものがビジネスロジックを記述する場所として機能する
                - ORMを使った場合、データアクセス層はORMがになっているので考えなくていいから
        - 二種類のビジネスロジック
            - コアなルール系
                - ジャンケンの勝敗判定
            - 処理の流れ系
                - コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ
        - 例
            - 「じゃんけんの勝敗判定」と「コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出すという流れ」は、どちらもビジネスロジック

- ビジネスロジックの二つの実装方法
    - トランザクションスクリプトパターン
        - トランザクションスクリプトパターンでは、「Service」クラスに処理を記述し、「DTO」をデータの入れ物としてやりとりする
        - DTO はデータと getter、setter だけ持ち、処理は Service に記述
        - 手続き型プログラミングの考え方でビジネスロジックを実装する方式
            - クラスを使っているが、オブジェクト指向をしていないということ

    - ドメインモデルパターン
        - ドメインモデルパターンでは、トランザクションスクリプトパターンではただの入れ物だった「DTO」に処理も持たせ、処理とデータを一緒に配置するオブジェクト指向的な実装をする
        - 処理とデータを入れるものを「ドメインモデル」と呼ぶ
            - MVCフレームワークを正しく使った場合、ドメインモデルを使ってビジネスロジックを実装していることになる

- 二種類のビジネスロジック
    - エンタープライズビジネスルール
        - エンタープライズビジネスルールというのは、システム都合ではない、コアなルールのこと
        - 例
            - じゃんけんの勝ち負け判定ロジックはシステムであっても現実であっても同じなので、「エンタープライズビジネスルール」
            - EC サイトで購入リクエストした商品が購入可能なものであるというチェックのロジックも「エンタープライズビジネスルール」

    - アプリケーションビジネスルール
        - アプリケーションビジネスルールは、システムを成立させるためのロジックや、システムであることによって発生したロジック
        - 「ユースケースの処理の流れを実現すること」や「トランザクション管理」などが該当
        - 例
            - 「コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ」
            - ECサイトで購入リクエストした商品が購入可能なものであるを例にダスト
                1. DB などから関係するデータを取り出す処理を呼び出す
                2. エンタープライズビジネスルールを呼び出して整合性をチェックする
                3. 整合性チェックに合格した場合、データを保存する処理を呼び出す (商品購入の確定など)
    
    - 補足
        - 3層アーキテクチャの代表例であるMVCアーキテクチャでは、二つのビジネスロジックを一つのmodelに記述しているが、クリーンアーキテクチャなどでは明確に二つに分けて記述する。
        - 4層アーキテクチャはビジネスロジック層をアプリケーション層とドメイン層に分けるが、エンタープライズビジネスルールに該当するものをドメイン層に書いて、アプリケーションビジネスルールはアプリケーション層に書くのだと思う。（多分）

- 二種類のサービス
    - https://qiita.com/os1ma/items/25725edfe3c2af93d735

- 参考文献
    - https://qiita.com/os1ma/items/25725edfe3c2af93d735    

---

## 色々なアーキテクチャ
- 3層アーキテクチャ
    - MVC
        - 「MVC」と「Model2のMVC」という二種類がある
        - WebアプリケーションではModel2のMVCをそのままMVCと呼んで使っている
        - デスクトップアプリケーションとかだと、前者の方らしい

        ![2020-11-13 17 33のイメージ](https://user-images.githubusercontent.com/53253817/99047442-93a20f80-25d7-11eb-916f-a547e61e246c.jpeg)

        ![https---qiita-image-store s3 amazonaws com-0-15902-545594a8-9bd1-b137-6ac0-c67519fda69f](https://user-images.githubusercontent.com/53253817/99075286-919e7780-25fc-11eb-99d3-4ee6ab067b69.jpeg)


    - MVP
        - パッシブビュー型のMVP
            - パッシブビューはModel2MVCとほぼ流れは変わらない
            - ModelとViewが完全に分離され、Presenterがその仲介を果たす
            
            ![https---qiita-image-store s3 amazonaws com-0-15902-dcecea88-3892-d74c-b73d-df3c2f38b362](https://user-images.githubusercontent.com/53253817/99075296-95ca9500-25fc-11eb-98d8-51490561d5d0.jpeg)


        - 監視コントローラ型のMVP
            - ViewがModelのデータ情報を監視(Observe)し、Modelの状態に応じて表示を変更
            - ただしデータの変更に関してはViewから直にModelを操作せずPresenterを挟んでModelへのデータ変更の処理を行う

            ![https---qiita-image-store s3 amazonaws com-0-15902-8c38b332-3e5e-dc8b-78e0-0c4f0a4b6c50](https://user-images.githubusercontent.com/53253817/99075299-97945880-25fc-11eb-8b03-e6df75cbe2b9.jpeg)


        - 共通点
            - Model, View, Presenterで構成される
            - PresenterにはViewのためのUIのビジネスロジックを書く
            - PresenterがViewへの参照を持ち、Modelが変更されたらViewを更新する
            - Viewはなるべく簡素なものとし、Presenterにて操作を行う。
        
        ![2020-11-13 17 33のイメージ](https://user-images.githubusercontent.com/53253817/99047458-969d0000-25d7-11eb-9251-bc12ba58d4ba.jpeg)

    - MVVM

        ![https---qiita-image-store s3 amazonaws com-0-15902-b3caa541-155f-4abd-746c-9f035217df48](https://user-images.githubusercontent.com/53253817/99075334-a67b0b00-25fc-11eb-9183-0172b7161728.jpeg)

    - 参考文献
        - https://qiita.com/shinkuFencer/items/f2651073fb71416b6cd7


- DDDアーキテクチャ
    - 4層アーキテクチャ(レイヤードアーキテクチャ)
        - 3層アーキテクチャのビジネスロジック層を「ドメイン層」と「アプリケーション層」に分割したアーキテクチャ
            - 要は、Modelの部分を分割してFatModelにならないようにしている感じかな
            - MVPアーキテクチャを4層にすると、Modelを「domain」と「data」に分割したもの

        
        ![2020-11-13 17 42のイメージ](https://user-images.githubusercontent.com/53253817/99047496-a0266800-25d7-11eb-81b1-29d953043171.jpeg)

        ![2020-11-13 17 34のイメージ](https://user-images.githubusercontent.com/53253817/99047471-9997f080-25d7-11eb-9f1d-813f222460f1.jpeg)

    - クリーンアーキテクチャ

        ![2020-11-13 17 37のイメージ](https://user-images.githubusercontent.com/53253817/99047482-9d2b7780-25d7-11eb-9fae-46b75f7c5545.jpeg)

- MVCと3層アーキテクチャの対応
    - ORMを使う場合データアクセス層がない
        - 「ない」というのは生のSQL発行をする必要がなくて、ORMが担ってくれているということ
    
    ![2020-11-13 16 45のイメージ](https://user-images.githubusercontent.com/53253817/99042140-98fb5c00-25cf-11eb-85ca-d18486aa2020.jpeg)

---

## Modelの設計パターン(MVCとかMVPとかのMの部分、DDDにおいてはDomainの部分)
- ActiveRecordパターン
    - ORMを使ってModelを設計すること
        - ActiveRecordはrailsの用語だが、djangoのORMに置き換えて考えて問題ない
    - 特徴
        - テーブルとクラスが1:1
        - rowとインスタンスが1:1
        - テーブルに対する操作をクラスメソッドに書く
            - インスタンス化しなくても呼び出せるメソッド。pythonなら「@classmethod」をつけると定義できる
        - rowに対する操作をインスタンスメソッドに書く
            - データに対する操作のこと
    - 問題点
        - 複数のテーブルにまたがるロジックはどうするのか？
            - テーブルとクラスが1:1だから、自分自身のクラスのrowに対する処理しか書かないのに、他のクラスのrowへの処理を書くのはおかしいから
        - トランザクションをどこで制御するのか？
            - トランザクションというのは、データベースに対して行われる1つ以上の更新処理のこと
            - rowとインスタンスが1:1だから、複数のrowを一つのインスタンスで処理するのはおかしいから
    - 用途
        - 単純なCRUDアプリならActiveRecordパターンで十分

- TransactionScriptをActiveRecordに導入
    - ORMを使って定義したModelの他にTransactionScriptのクラスを用意して、その中で複数のモデルに対する処理を書いたり、トランザクションを制御したりする
    - 特徴
        - ユースケースと1:1のメソッド
            - 要は複数のModelを使用して一つのユースケースを満たすということ
        - ユースケースに対応する手続きをそのメソッドに書いていく
            - 複数のModelを使って処理の流れを作成するということ

- Layered Architectureで行う(ARもTSも使っていないと思う)
    - 「Presentation -> ApplicationService -> DomainModel <- Infrastructure」の構成
        - Presentation(interface層、プレゼンテーション層)
            - goで例える
                - ルーティングはmainが行うので、Presentation層ではない。
                - ルーティングされるハンドラ関数はPresentation層で定義する
                - ハンドラ関数の中でユースケース(ApplicationServiceに定義されている)を呼び出す
                    - 一つのハンドラ関数に対してユースケースは一つ。なぜかと言うと、処理の流れはユースケースの中に書かれているから
                - ユースケースから返ってきた値を出力する
            - 処理の例
                - HTTPを受け取り、それに対応したユースケース(ApplicationServiceに属している)を呼び出す
                    - リクエストデータをユースケースの引数に渡して呼び出す
                - 一つのユースケースが実行される
                - ユースケースから何らかの値が返ってくるから、返ってきた値を出力する(webアプリなら画面出力)
        - ApplicationService(アプリケーション層、ユースケース層)
            - ユースケースを満たすために処理の流れを記述するところ
            - ユースケースを満たすために複数のビジネスロジック(DomainModelに定義されている)のメソッドが実行されて一つのユースケースを作りだす
            - ハンドラ関数から呼び出される。一つのハンドラ関数につき一つのユースケースが存在する
            - 処理の例
                - ビジネスロジックAでユーザの一覧を受け取る
                - ユーザの一覧をビジネスロジックBの引数に渡して男のユーザ一覧だけを受け取る
        - DomainModel(ドメイン層)
            - ビジネスロジックを定義するところ
            - ここがModelにあたる
            - 定義する二種類のビジネスロジック
                - コアなルール系
                    - ジャンケンの勝敗判定
                - 処理の流れ系
                    - コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ
                        - この場合は、「コンピュータとジャンケンした結果を返すメソッド」と「保存するメソッド」に分けて、ユースケースでその流れを定義したほうがいい気がする。
                            - 注意する点は「保存するメソッド」の際に、実際にSQLを発行する処理はInfrastructure層に書くこと。
                            - そして、Applicationserviceから、そのSQLを発行するメソッドをジャンケン結果を引数にして呼び出す
        - Infrastructure(データアクセス層)
            - DBアクセスとか(SQL発行)
            - APIへのアクセスとかもだと思う
            - 直接handler、usecaseから呼ばれることもあるが、基本的にdomainのインターフェースによって抽象化される
                - DDDではDIP(依存関係逆転の原則)を用いてInfrastructure層がDomainModelにしか依存していないことから、ApplicationServiceやPresentationから呼び出されることがある
    - 恩恵
        - 責務が分散された
        - 複雑なTransactionScriptはテストが大変
        - テストがしやすくなった
        - DomainModelはDBなしでテストできる

- Clean Architecture(クリーンアーキテクチャ)

- わかったこと
    - DDDで「ユースケース図」を作る理由は、ApplicationService(ユースケース層)を作成するために必要な設計
        - もっと知りたかったら、「モデルベース要件定義テクニック(RDRA)」を読む
    - DDDで「コンテキストモデル図、要求モデル図、ドメインモデル図」を作る理由は、DomainModel層(ドメイン層)を作成するために必要な設計
        - もっと知りたかったら、「ユースケース駆動開発実践ガイド(ICONIX)」を読む
    - DDDでもサブディレクトリ（サブパッケージ）は積極的に使っていい。例えば、Infrastructure層に書くもので、DBとFrameWorkの二つが出てきたら、DBというディレクトリとFrameWorkをというディレクトリをInfrastructureディレクトリのサブディレクトリとして作成していい
    - 不安定なものは安定しているものに依存しないといけないということがわかった
        - DomainModelは滅多に変更されない「安定したもの」
        - Infrastructureは頻繁に変更される「不安定なもの」
            - APIの内容が変更になったりするから

- 参考文献
    - https://speakerdeck.com/shinpeim/afalseri-jian-ta-m-v-whateverfalse-modelwopu-tatiha-madazhi-ranai?slide=65
    - https://mintaku-blog.net/go-ddd/
    - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338


---

## クリーンアーキテクチャの成り立ち
- https://qiita.com/kz_12/items/bc79102247b86626fc72



---


## アーキテクチャの選択
- MVCの問題点
    - Modelの定義が曖昧だから責務が集中してしまってFatModelになってしまうことが多い

- 小規模なアプリケーションならMVCとかでいいと思う
    - 割とAPIを作成する際などは現場でもMVCは選択されるみたい？？

- マイクロサービスとかなら、一つ一つのアプリケーションを小さくすればMVCので済むのではないか？
    - 一つ一つのアプリケーションが大規模ならクリーンアーキテクチャなど採用しないといけないかもしれないが

- クリーンアーキテクチャを採用するときは、クラス数が増大するからメモリの問題を加味してマシンスペックを考えないといけない

---

## ドメイン駆動設計を勉強する手順
1. まず基礎知識を頭に入れる
    - https://www.slideshare.net/TakuyaKitamura1/ddd-29003356
    - https://logmi.jp/tech/articles/310424

2. 体系的に学習する
    - https://nrslib.com/bottomup-ddd/
    - https://nrslib.com/bottomup-ddd-2/
    - ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本
        - 上の２つの記事を書籍化したもの

3. 実践的な書籍を読む
    - ドメイン駆動設計 モデリング/実装ガイド
        - https://little-hands.booth.pm/items/1835632

4. ドメインモデルとユースケースに絞った書籍を読む
    - モデルベース要件定義テクニック(RDRA)
    - ユースケース駆動開発実践ガイド(ICONIX)

5. とりあえず簡単なプログラムを作ってみる
    - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338
    - https://qiita.com/hirotakan/items/698c1f5773a3cca6193e

6. 最後の仕上げに難しめな本を読む
    - エリック・エヴァンスのドメイン駆動設計
    - 実践ドメイン駆動設計

---

## 合っているかわからないけど残しておくメモ
- MVCとアプリケーションアーキテクチャの関係を理解するためのフロー
    1. MVCだとModelは「データ」というフィールドと「ビジネスロジック」というメソッドを持っている
    2. MVCだとModelが大きくなりすぎてしまう
    3. Modelの部分の設計を考え直したほうがいいのではないか

- クリーンアーキテクチャの解説
    1. ドメインにデータとビジネスロジックを定義。これをエンティティという
    2. その前の層はそのエンティティ同士を協調させて、ユースケースを達成する(アプリケーションとしての動作を満たすということ)
        - エンティティを使って処理の流れを実装する感じかな
    3. その前の層は入力、永続化、表示を担当するオブジェクトが所属
    4. その前の層は

- アプリケーションアーキテクチャは以下の3つを決める
    - レイヤー構成
        - 3層、レイヤード、ヘキサゴナル、クリーン、オニオン、etc
    - プレゼンテーション層
        - MVC、MVP、MVVM、etc
    - ビジネスロジック層
        - トランザクションスクリプト、ドメインモデル
    - 例
        - 「レイヤー構成は3層でプレゼンテーション層はMVCでビジネスロジック層はドメインモデル」といった決め方をする

---

## ドメイン駆動開発
- DDDを適用したレイヤードアーキテクチャ(4層アーキテクチャ)
    - DDDではDIP(依存関係逆転の原則)を用いて下の図のような依存関係になる

    - interface層
        - HTTPを受け取り、usecaseを呼び結果を出力(JSONやHTML)
    
    - usecase層
        - アプリケーションレイヤでシステム使用上のユースケースを表現
            - ユーザ登録、ユーザ覧表示など
        - handlerから呼びされる
            - 1つのhandlerに対応する専用usecaseが1つ存在します
        - 基本的にはdomainを触る
    
    - domain層
        - モデルレイヤでドメイン(システムが扱う業務領域)に関する値と振る舞いを持つ
        - 他のレイヤに依存しない
    
    - infrastructure層
        - 技術的関心ごとを扱うレイヤで具体的な技術に関する処理を書く
            - DBやMail操作など
        - 直接handler、usecaseから呼ばれることもあるが、基本的にdomainのインターフェースによって抽象化される
    
    - 参考文献
        - goで実装している
            - https://mintaku-blog.net/go-ddd/
            - https://qiita.com/tono-maron/items/345c433b86f74d314c8d
            - https://yyh-gl.github.io/tech-blog/blog/go_web_api/


        ![2020-11-13 4 50のイメージ (1)](https://user-images.githubusercontent.com/53253817/98988955-c4e4f600-256b-11eb-9638-f23c6d03b2ee.jpeg)

- DDDとユースケース図の関係
    - DDDで重要となるドメインの部分をユースケース図とドメインモデル図というもので決めれるらしい
        - これをユースケース駆動開発とか言われているらしい
        - UMLというのは組み合わせることで、新しい概念
    - https://logmi.jp/tech/articles/322835

- ちゃんとしたDDDの進め方(DDD固有のものは1-6だと思う。そのほかは一般的な開発の進め方)
    1. コンテキストモデル
    2. 要求モデル(要望の洗い出し)
    3. 要求モデル(要求の洗い出し)
    4. 要求モデル(要件の洗い出し)
    5. ドメインモデル
    6. ユースケースモデリング(ユースケース図)
    7. 画面設計(画面遷移図)
    8. 画面設計(ワイヤーフレーム)
    9. ユースケースモデリング(ユースケース記述)
    10. ロバストネス分析
    11. クラス図
    12. データモデリング(ER図)
    13. UI設計
    14. 実装に入る...
    - 参考文献
        - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338

- 大規模な開発
    - マイクロサービスでは、複数のアプリケーションを連携させて構築するが、一つ一つのアプリケーションはクリーンアーキテクチャなどを使って開発していくことになる

- あとで以下をしっかりまとめる
    - https://qiita.com/os1ma/items/7a229585ebdd8b7d86c2
    - https://qiita.com/tentom/items/653d46ded6e292630a6c
    - http://geekna.hatenablog.jp/entry/20110824/p1
    - https://www.yo1000.com/ddd-transcript
    - iosアプリをmvc,mvp,mvvm,clean-architectureで実装
        - https://medium.com/@rockname/clean-archirecture-7be37f34c943
    - レイヤードアーキテクチャにMVCを当てはめると
        - https://qiita.com/yuku_t/items/961194a5443b618a4cac
    - go言語でレイヤードアーキテクチャ+DDD
        - https://qiita.com/tono-maron/items/345c433b86f74d314c8d
---

