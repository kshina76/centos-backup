# アプリケーションーアーキテクチャのメモ

## webアプリケーションに置いてMVC、MVP、MVVMとかアーキテクチャとかよく分からなくなった時に読んで欲しいこと

- MVCやMVPやMVVMはあくまでもUIアーキテクチャということを忘れずに
    - UIアーキテクチャは、「UIに関するロジック(プレゼンテーション層)」と「システムに関するビジネスロジック」を分離することが目的
        - しかし、プレゼンテーション層から分離された「システムに関するビジネスロジック」にはルールがないため、DB接続、API通信など色々なものが盛り込まれてしまって、FatModelになってしまう。
            - そこで、レイヤードアーキテクチャやクリーンアーキテクチャーが誕生する
                - これは、Modelにあたる「システムに関するビジネスロジック」をさらに細分化するためのアーキテクチャ
                    - つまり「MVCやMVPやMVVM」の「VC, VP, VVM」は全てプレゼンテーション層のみの設計で、Modelの設計に関してはアプリケーション層以降の層を設計することと同値の意味を持つ
    - https://qiita.com/navitime_tech/items/602d3286f23952ae0149
    - https://qiita.com/os1ma/items/7a229585ebdd8b7d86c2

- アーキテクチャの選び方(例)
    - UIアーキテクチャはMVPを使って、Modelの設計はレイヤードアーキテクチャを採用する
    - UIアーキテクチャはMVCを使って、Modelの設計はクリーンアーキテクチャを採用する

- API開発に関しては3層なのか4層なのかクリーンなのかということだけ考えればいい
    - API開発においてのアーキテクチャ内のプレゼンテーション層の扱い
        - APIにはViewは無いので(TemplateのUI表示は無いから)、プレゼンテーション層はControllerだけになる。
            - Controllerはハンドラ関数を定義して、実行する場所なので、それだけを行う
                - もし4層で行うなら、ユースケース層があるので、一つのハンドラ関数に一つのユースケースを呼び出す構成になると思う
            - APIにおいては、MVCとかMVPとかMVVMとかの概念は無いと考えていいと思う。あえて言葉をつけるとしたら、MC、MPとか？
                - つまりAPIに関しては3層なのか4層なのかクリーンなのかということだけ考えればいい

    - goで色々なアーキテクチャでAPIを実装している
        - https://qiita.com/ogady/items/34aae1b2af3080e0fec4
        - https://qiita.com/hmarf/items/7f4d39c48775c205b99b
        - https://qiita.com/yuukiyuuki327/items/238814326964e06dd655
        - https://qiita.com/ryokky59/items/6c2b35169fb6acafce15

- アーキテクチャ早見表
    - 3層
        - プレゼンテーション層
            - ハンドラ関数で定義して、ビジネスロジック層を呼び出す。
            - ビジネスロジック層からの返り値とTemplateを使って画面表示する(ExecuteでTemplateエンジンを呼び出す)
        - ビジネスロジック層
            - Modelの部分。データと振る舞いをビジネスロジックとして定義
        - データアクセス層
            - Modelの部分。SQL発行してDB接続やAPI接続など
    - レイヤードアーキテクチャ(4層)
        - プレゼンテーション層
            - ハンドラ関数で定義して、アプリケーション層を呼び出す(ユースケース)、ハンドラ関数一つにつき一つのユースケース
            - アプリケーション層からの返り値とTemplateを使って画面表示する(ExecuteでTemplateエンジンを呼び出す)
        - アプリケーション層
            - 複数モデルにまたがるビジネスロジックをユースケースとして定義。ドメイン層を呼びだす。
            - 返り値はプレゼンテーション層へ
        - ドメイン層
            - データと振る舞いをビジネスロジックとして定義
            - 返り値はアプリケーション層へ
        - データアクセス層
            - SQL発行してDB接続、API接続など
            - 返り値はどこに行くのだろう？？goでAPIを実装しているものを参考にしてわかったらここに書く
    - クリーンアーキテクチャ
        - 

- 層の用語置き換え
    - プレゼンテーション層 <-> UI層, Interface
    - アプリケーション層 <-> ApplicationService層, Application層, usecase層
    - ドメイン層 <-> DomeinModel層, Domain層
    - データアクセス層 <-> Infrastructure層

## 正しいMVCアーキテクチャの理解
- MVCアーキテクチャの種類(MoldelとViewの繋ぎ方で分類)
    - Controller(Presenter)が仲介パターン
        1. Push-MVC(Web)、MVC2(Web)
            - Model
                - データとビジネスロジックを定義
                - DB接続(SQL発行)
                - API接続
            - View
                - HTMLやTempalteの定義
                    - Template.Execute(テンプレートエンジン)自体の実装はViewが行っているが、ライブラリを使っている。呼び出しはControllerから。
            - Controller
                - ユーザ入力の窓口
                - go言語でいうハンドラ関数が行う部分
                - Modelに実装されているビジネスロジックの呼び出し
                    - 複数モデルにまたがる処理(ユースケース層的な役割もあるということかな？)
                - Viewを呼び出す処理
                    - go言語において、Template.Executeを呼び出すこと
                    - Modelから返ってきたデータをTemplateエンジン(View)に渡す
            - URLルーティングはMVCではなくてmainの外の処理が行うことだから混同しないように注意する
            - データをViewにpushすることからこのような名前がついている

        2. MVP-Passive-View(Web)
            - Model
                - ViewとPresenter以外
                - API接続
                - DB接続(SQL発行)
                - データとビジネスロジック(プレゼンテーションロジックはPresenterで定義)
                - ViewとPresenterには依存しない
                    - ModelからPresenterとViewを参照することはないということ
            - View
                - ユーザ入力の窓口
                - UIのレイアウトを定義
                    - HTMLとかTempalteとか
                - ユーザアクション(イベント)、ユーザ入力をPresenterに通知(ボタン押されたから処理しといてーとかを入力データと一緒に渡す)
                    - ViewにOnClickメソッドが実装されていて、実行するけど、中身はPresenterに委譲するだけしか書かれていない
                        - 委譲というのはViewでPresenterのクラスの変数を持っていて、その変数からPresenterのOnClickを呼び出すこと
                            - デリゲート(委譲)とは「Presenterに処理をしてもらう」という意味
            - Presenter
                - ViewとModelを仲介する
                    - User->View->Presenter->Model->Presenter->View->User
                    - User->View->Presenter->View->User
                - Viewから受け取ったユーザアクションに対するハンドラ(イベントハンドラ)を実装、実行
                    - プレゼンテーションロジック(UIのビジネスロジック)という
                    - PresenterのハンドラからViewのインタフェースを経由してViewのメソッドを呼び出してUIの更新処理をする
                        - Viewのメソッド内にTemplateのExecuteとかが実装されているから、それを呼び出して更新するということ
            
            ![MVP](https://user-images.githubusercontent.com/53253817/99233802-12e14e80-2837-11eb-957f-6301ad3be3e5.png)

            - WebにおいてはViewのユーザ入力をPresenterに通知をURLルーティングが担ってくれているのかもしれない
                - GUIに関してはViewでOnCLickを定義してPresenterに流す処理を書くのかもしれない

            - MVPのメリット・デメリット
                - ModelとViewが別れているからテストがしやすい
                - Presenterが膨れる傾向にある

            - MVPにおけるオブジェクトの生成過程
                1. アプリを起動すると View が生成される。
                2. View は自分自身を制御してもらうための Presenter を生成する。Presenter に自分自身の参照を渡しておく。
                3. Presenter はビジネスロジックを実行するための Model を生成する。
                - https://light11.hatenadiary.com/entry/2019/01/23/231828
            
            - MVPにおける処理の例
                - "Save"Buttonクリック→ViewのイベントハンドラはPresenterにデリゲートされているので、Presenterで"OnSave"が呼び出される→セーブが終わったら、PresenterからInterfaceを通してViewにセーブされたよって表示する。

        3. MVP(GUI)
            - 
    
    - ViewがModelを参照パターン
        1. Pull-MVC(Web),MVC1(GUI)
            - ViewがModelを参照してデータを取得するパターン
            - Webではあまり普及していない。HTML5を使ったSynthというフレームワークが存在する
            - 「やはりお前らのMVCは間違っている」で紹介されているGUIにおける古典的なMVC
        2. MVP-Supervising-Controller(Web)

    - 参考文献
        - MVPの実装がわかりやすかった
            - https://light11.hatenadiary.com/entry/2019/01/23/231828
        - MVPの際のシーケンス図がわかりやすかった
            - https://maku.blog/p/5wu6fbv/

- WebにおいてどのMVCアーキテクチャがいいのか
    - Push-MVCを選択するべき

- Pull-MVCをWebで実現するのは大変
    - HTTPはステートレスであるという点が、ViewがどのModelに関連付けられていたのか、という情報を失わせる。これを回避するため、セッションにViewとModelを関連づける情報を保持する必要がある。そのため、Pull-MVCのフレームワークは実装が難しく、あまりメリットがないので、少ないのが現状
    - HTML5においては可能。Synthというフレームワークが存在する

- わかったこと
    - 上記のMVPの図でクラスの機能を使いたい時には継承ではなく委譲を使っていることがわかる
        - OOPで別クラスの機能を用いたい時は、委譲を使って「インスタンス変数としてクラスを持ち、メソッドでそのクラスのインスタンス化をする」

- https://at-grandpa.hatenablog.jp/entry/2013/11/01/072636
- https://www.slideshare.net/MugeSo/mvc-14469802
- https://qiita.com/MasashiFujiike/items/5c1c3e92c0289812a952

## 3層アーキテクチャと層の詳細
- 3層アーキテクチャ
    - データアクセス
        - データアクセス層の役割は、ファイルや DB に対してデータを読み書きすること
        - ビジネスロジックをデータアクセスと切り離すというのは、保存先がファイルだろうと、RDB だろうと、ドキュメント DB だろうと、ビジネスロジックはそれを気にかけないように記述するということ
        - データアクセス層は、保存先の媒体によらず同じインタフェースをビジネスロジック層に対して提供して、保存先が変わってもデータアクセス層だけ直せばいいというのが理想的
    
    - プレゼンテーション
        - プレゼンテーション層とは、そのアプリケーションとユーザ (またはクライアントプログラムなど) とのやりとりを担当する層
        - 古典的なMVCフレームワークによるWebアプリと同様の処理をAPIやCLIアプリケーションとして提供するとき、プレゼンテーション層以外が使い回せるような構造になっていると理想的。その使い回すべき部分のうち、データアクセスではない部分がビジネスロジック。
        - プレゼンテーション層の例
            - 古典的な MVC フレームワークの場合 ... View や Controller
            - API の場合 ... API を受け付ける Controller・リクエストやレスポンスの型
            - CLI アプリケーションの場合 ... コマンドラインオプションの解析・ユーザからの入力受付・処理結果の出力
    
    - ビジネスロジック
        - アプリケーションをプレゼンテーション・ビジネスロジック・データアクセスの 3 つに分けたとき、「プレゼンテーションでもデータアクセスでもない部分がビジネスロジック」
            - MVCアーキテクチャにおいてORMを使った場合、Modelそのものがビジネスロジックを記述する場所として機能する
                - ORMを使った場合、データアクセス層はORMがになっているので考えなくていいから
        - 二種類のビジネスロジック
            - コアなルール系
                - ジャンケンの勝敗判定
            - 処理の流れ系
                - コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ
        - 例
            - 「じゃんけんの勝敗判定」と「コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出すという流れ」は、どちらもビジネスロジック

- ビジネスロジックの二つの実装方法
    - トランザクションスクリプトパターン
        - トランザクションスクリプトパターンでは、「Service」クラスに処理を記述し、「DTO」をデータの入れ物としてやりとりする
        - DTO はデータと getter、setter だけ持ち、処理は Service に記述
        - 手続き型プログラミングの考え方でビジネスロジックを実装する方式
            - クラスを使っているが、オブジェクト指向をしていないということ

    - ドメインモデルパターン
        - ドメインモデルパターンでは、トランザクションスクリプトパターンではただの入れ物だった「DTO」に処理も持たせ、処理とデータを一緒に配置するオブジェクト指向的な実装をする
        - 処理とデータを入れるものを「ドメインモデル」と呼ぶ
            - MVCフレームワークを正しく使った場合、ドメインモデルを使ってビジネスロジックを実装していることになる

- 二種類のビジネスロジック
    - エンタープライズビジネスルール
        - エンタープライズビジネスルールというのは、システム都合ではない、コアなルールのこと
        - 例
            - じゃんけんの勝ち負け判定ロジックはシステムであっても現実であっても同じなので、「エンタープライズビジネスルール」
            - EC サイトで購入リクエストした商品が購入可能なものであるというチェックのロジックも「エンタープライズビジネスルール」

    - アプリケーションビジネスルール
        - アプリケーションビジネスルールは、システムを成立させるためのロジックや、システムであることによって発生したロジック
        - 「ユースケースの処理の流れを実現すること」や「トランザクション管理」などが該当
        - 例
            - 「コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ」
            - ECサイトで購入リクエストした商品が購入可能なものであるを例にダスト
                1. DB などから関係するデータを取り出す処理を呼び出す
                2. エンタープライズビジネスルールを呼び出して整合性をチェックする
                3. 整合性チェックに合格した場合、データを保存する処理を呼び出す (商品購入の確定など)
    
    - 補足
        - 3層アーキテクチャの代表例であるMVCアーキテクチャでは、二つのビジネスロジックを一つのmodelに記述しているが、クリーンアーキテクチャなどでは明確に二つに分けて記述する。
        - 4層アーキテクチャはビジネスロジック層をアプリケーション層とドメイン層に分けるが、エンタープライズビジネスルールに該当するものをドメイン層に書いて、アプリケーションビジネスルールはアプリケーション層に書くのだと思う。（多分）

- 二種類のサービス
    - https://qiita.com/os1ma/items/25725edfe3c2af93d735

- 参考文献
    - https://qiita.com/os1ma/items/25725edfe3c2af93d735    

---

## 色々なアーキテクチャ
- 3層アーキテクチャ
    - MVC
        - 「MVC」と「Model2のMVC」という二種類がある
        - WebアプリケーションではModel2のMVCをそのままMVCと呼んで使っている
        - デスクトップアプリケーションとかだと、前者の方らしい

        ![2020-11-13 17 33のイメージ](https://user-images.githubusercontent.com/53253817/99047442-93a20f80-25d7-11eb-916f-a547e61e246c.jpeg)

        ![https---qiita-image-store s3 amazonaws com-0-15902-545594a8-9bd1-b137-6ac0-c67519fda69f](https://user-images.githubusercontent.com/53253817/99075286-919e7780-25fc-11eb-99d3-4ee6ab067b69.jpeg)


    - MVP
        - パッシブビュー型のMVP
            - パッシブビューはModel2MVCとほぼ流れは変わらない
            - ModelとViewが完全に分離され、Presenterがその仲介を果たす
            
            ![https---qiita-image-store s3 amazonaws com-0-15902-dcecea88-3892-d74c-b73d-df3c2f38b362](https://user-images.githubusercontent.com/53253817/99075296-95ca9500-25fc-11eb-98d8-51490561d5d0.jpeg)


        - 監視コントローラ型のMVP
            - ViewがModelのデータ情報を監視(Observe)し、Modelの状態に応じて表示を変更
            - ただしデータの変更に関してはViewから直にModelを操作せずPresenterを挟んでModelへのデータ変更の処理を行う

            ![https---qiita-image-store s3 amazonaws com-0-15902-8c38b332-3e5e-dc8b-78e0-0c4f0a4b6c50](https://user-images.githubusercontent.com/53253817/99075299-97945880-25fc-11eb-8b03-e6df75cbe2b9.jpeg)


        - 共通点
            - Model, View, Presenterで構成される
            - PresenterにはViewのためのUIのビジネスロジックを書く
            - PresenterがViewへの参照を持ち、Modelが変更されたらViewを更新する
            - Viewはなるべく簡素なものとし、Presenterにて操作を行う。
        
        ![2020-11-13 17 33のイメージ](https://user-images.githubusercontent.com/53253817/99047458-969d0000-25d7-11eb-9251-bc12ba58d4ba.jpeg)

    - MVVM

        ![https---qiita-image-store s3 amazonaws com-0-15902-b3caa541-155f-4abd-746c-9f035217df48](https://user-images.githubusercontent.com/53253817/99075334-a67b0b00-25fc-11eb-9183-0172b7161728.jpeg)

    - 参考文献
        - https://qiita.com/shinkuFencer/items/f2651073fb71416b6cd7


- DDDアーキテクチャ
    - 4層アーキテクチャ(レイヤードアーキテクチャ)
        - 3層アーキテクチャのビジネスロジック層を「ドメイン層」と「アプリケーション層」に分割したアーキテクチャ
            - 要は、Modelの部分を分割してFatModelになりすぎないようにしている感じかな
            - MVPアーキテクチャを4層にすると、Modelを「domain」と「data」に分割したもの
        - 「4層」と「DDDの4層」の用語の対応
            - プレゼンテーション層 -> UI層, Interface
            - アプリケーション層 -> ApplicationService層, Application層, usecase層
            - ドメイン層 -> DomeinModel層, Domain層
            - データアクセス層 -> Infrastructure層

        ![2020-11-13 17 42のイメージ](https://user-images.githubusercontent.com/53253817/99047496-a0266800-25d7-11eb-81b1-29d953043171.jpeg)

        ![2020-11-13 17 34のイメージ](https://user-images.githubusercontent.com/53253817/99047471-9997f080-25d7-11eb-9f1d-813f222460f1.jpeg)

    - クリーンアーキテクチャ

        ![2020-11-13 17 37のイメージ](https://user-images.githubusercontent.com/53253817/99047482-9d2b7780-25d7-11eb-9fae-46b75f7c5545.jpeg)

- MVCと3層アーキテクチャの対応
    - ORMを使う場合データアクセス層がない
        - 「ない」というのは生のSQL発行をする必要がなくて、ORMが担ってくれているということ
    
    ![2020-11-13 16 45のイメージ](https://user-images.githubusercontent.com/53253817/99042140-98fb5c00-25cf-11eb-85ca-d18486aa2020.jpeg)

---

## Modelの設計パターン(MVCとかMVPとかのMの部分、DDDにおいてはDomainの部分)
- ActiveRecordパターン
    - ORMを使ってModelを設計すること
        - ActiveRecordはrailsの用語だが、djangoのORMに置き換えて考えて問題ない
    - 特徴
        - テーブルとクラスが1:1
        - rowとインスタンスが1:1
        - テーブルに対する操作をクラスメソッドに書く
            - インスタンス化しなくても呼び出せるメソッド。pythonなら「@classmethod」をつけると定義できる
        - rowに対する操作をインスタンスメソッドに書く
            - データに対する操作のこと
    - 問題点
        - 複数のテーブルにまたがるロジックはどうするのか？
            - テーブルとクラスが1:1だから、自分自身のクラスのrowに対する処理しか書かないのに、他のクラスのrowへの処理を書くのはおかしいから
        - トランザクションをどこで制御するのか？
            - トランザクションというのは、データベースに対して行われる1つ以上の更新処理のこと
            - rowとインスタンスが1:1だから、複数のrowを一つのインスタンスで処理するのはおかしいから
    - 用途
        - 単純なCRUDアプリならActiveRecordパターンで十分

- TransactionScriptをActiveRecordに導入
    - ORMを使って定義したModelの他にTransactionScriptのクラスを用意して、その中で複数のモデルに対する処理を書いたり、トランザクションを制御したりする
    - 特徴
        - ユースケースと1:1のメソッド
            - 要は複数のModelを使用して一つのユースケースを満たすということ
        - ユースケースに対応する手続きをそのメソッドに書いていく
            - 複数のModelを使って処理の流れを作成するということ

- Layered Architectureで行う(ARもTSも使っていないと思う)
    - 「Presentation -> ApplicationService -> DomainModel <- Infrastructure」の構成
        - Presentation(interface層、プレゼンテーション層)
            - goで例える
                - ルーティングはmainが行うので、Presentation層ではない。
                - ルーティングされるハンドラ関数はPresentation層で定義する
                - ハンドラ関数の中でユースケース(ApplicationServiceに定義されている)を呼び出す
                    - 一つのハンドラ関数に対してユースケースは一つ。なぜかと言うと、処理の流れはユースケースの中に書かれているから
                - ユースケースから返ってきた値を出力する
            - 処理の例
                - HTTPを受け取り、それに対応したユースケース(ApplicationServiceに属している)を呼び出す
                    - リクエストデータをユースケースの引数に渡して呼び出す
                - 一つのユースケースが実行される
                - ユースケースから何らかの値が返ってくるから、返ってきた値を出力する(webアプリなら画面出力)
        - ApplicationService(アプリケーション層、ユースケース層)
            - ユースケースを満たすために処理の流れを記述するところ
            - ユースケースを満たすために複数のビジネスロジック(DomainModelに定義されている)のメソッドが実行されて一つのユースケースを作りだす
            - ハンドラ関数から呼び出される。一つのハンドラ関数につき一つのユースケースが存在する
            - 処理の例
                - ビジネスロジックAでユーザの一覧を受け取る
                - ユーザの一覧をビジネスロジックBの引数に渡して男のユーザ一覧だけを受け取る
        - DomainModel(ドメイン層)
            - ビジネスロジックを定義するところ
            - ここがModelにあたる
            - 定義する二種類のビジネスロジック
                - コアなルール系
                    - ジャンケンの勝敗判定
                - 処理の流れ系
                    - コンピュータとじゃんけんをして、その結果をどこかに保存する処理を呼び出す、一連の流れ
                        - この場合は、「コンピュータとジャンケンした結果を返すメソッド」と「保存するメソッド」に分けて、ユースケースでその流れを定義したほうがいい気がする。
                            - 注意する点は「保存するメソッド」の際に、実際にSQLを発行する処理はInfrastructure層に書くこと。
                            - そして、Applicationserviceから、そのSQLを発行するメソッドをジャンケン結果を引数にして呼び出す
        - Infrastructure(データアクセス層)
            - DBアクセスとか(SQL発行)
            - APIへのアクセスとかもだと思う
            - 直接handler、usecaseから呼ばれることもあるが、基本的にdomainのインターフェースによって抽象化される
                - DDDではDIP(依存関係逆転の原則)を用いてInfrastructure層がDomainModelにしか依存していないことから、ApplicationServiceやPresentationから呼び出されることがある
    - 恩恵
        - 責務が分散された
        - 複雑なTransactionScriptはテストが大変
        - テストがしやすくなった
        - DomainModelはDBなしでテストできる

- Clean Architecture(クリーンアーキテクチャ)

- わかったこと
    - DDDで「ユースケース図」を作る理由は、ApplicationService(ユースケース層)を作成するために必要な設計
        - もっと知りたかったら、「モデルベース要件定義テクニック(RDRA)」を読む
    - DDDで「コンテキストモデル図、要求モデル図、ドメインモデル図」を作る理由は、DomainModel層(ドメイン層)を作成するために必要な設計
        - もっと知りたかったら、「ユースケース駆動開発実践ガイド(ICONIX)」を読む
    - DDDでもサブディレクトリ（サブパッケージ）は積極的に使っていい。例えば、Infrastructure層に書くもので、DBとFrameWorkの二つが出てきたら、DBというディレクトリとFrameWorkをというディレクトリをInfrastructureディレクトリのサブディレクトリとして作成していい
    - 不安定なものは安定しているものに依存しないといけないということがわかった
        - DomainModelは滅多に変更されない「安定したもの」
        - Infrastructureは頻繁に変更される「不安定なもの」
            - APIの内容が変更になったりするから

- 参考文献
    - https://speakerdeck.com/shinpeim/afalseri-jian-ta-m-v-whateverfalse-modelwopu-tatiha-madazhi-ranai?slide=65
    - https://mintaku-blog.net/go-ddd/
    - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338


---

## クリーンアーキテクチャの成り立ち
- https://qiita.com/kz_12/items/bc79102247b86626fc72



---


## アーキテクチャの選択
- MVCの問題点
    - Modelの定義が曖昧だから責務が集中してしまってFatModelになってしまうことが多い

- 小規模なアプリケーションならMVCとかでいいと思う
    - 割とAPIを作成する際などは現場でもMVCは選択されるみたい？？

- マイクロサービスとかなら、一つ一つのアプリケーションを小さくすればMVCので済むのではないか？
    - 一つ一つのアプリケーションが大規模ならクリーンアーキテクチャなど採用しないといけないかもしれないが

- クリーンアーキテクチャを採用するときは、クラス数が増大するからメモリの問題を加味してマシンスペックを考えないといけない

---

## ドメイン駆動設計を勉強する手順
1. まず基礎知識を頭に入れる
    - https://www.slideshare.net/TakuyaKitamura1/ddd-29003356
    - https://logmi.jp/tech/articles/310424

2. 体系的に学習する
    - https://nrslib.com/bottomup-ddd/
    - https://nrslib.com/bottomup-ddd-2/
    - ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本
        - 上の２つの記事を書籍化したもの

3. 実践的な書籍を読む
    - ドメイン駆動設計 モデリング/実装ガイド
        - https://little-hands.booth.pm/items/1835632

4. ドメインモデルとユースケースに絞った書籍を読む
    - モデルベース要件定義テクニック(RDRA)
    - ユースケース駆動開発実践ガイド(ICONIX)

5. とりあえず簡単なプログラムを作ってみる
    - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338
    - https://qiita.com/hirotakan/items/698c1f5773a3cca6193e

6. 最後の仕上げに難しめな本を読む
    - エリック・エヴァンスのドメイン駆動設計
    - 実践ドメイン駆動設計

---

## 合っているかわからないけど残しておくメモ
- MVCとアプリケーションアーキテクチャの関係を理解するためのフロー
    1. MVCだとModelは「データ」というフィールドと「ビジネスロジック」というメソッドを持っている
    2. MVCだとModelが大きくなりすぎてしまう
    3. Modelの部分の設計を考え直したほうがいいのではないか

- クリーンアーキテクチャの解説
    1. ドメインにデータとビジネスロジックを定義。これをエンティティという
    2. その前の層はそのエンティティ同士を協調させて、ユースケースを達成する(アプリケーションとしての動作を満たすということ)
        - エンティティを使って処理の流れを実装する感じかな
    3. その前の層は入力、永続化、表示を担当するオブジェクトが所属
    4. その前の層は

- アプリケーションアーキテクチャは以下の3つを決める
    - レイヤー構成
        - 3層、レイヤード、ヘキサゴナル、クリーン、オニオン、etc
    - プレゼンテーション層
        - MVC、MVP、MVVM、etc
    - ビジネスロジック層
        - トランザクションスクリプト、ドメインモデル
    - 例
        - 「レイヤー構成は3層でプレゼンテーション層はMVCでビジネスロジック層はドメインモデル」といった決め方をする

---

## ドメイン駆動開発
- DDDを適用したレイヤードアーキテクチャ(4層アーキテクチャ)
    - DDDではDIP(依存関係逆転の原則)を用いて下の図のような依存関係になる

    - interface層
        - HTTPを受け取り、usecaseを呼び結果を出力(JSONやHTML)
    
    - usecase層
        - アプリケーションレイヤでシステム使用上のユースケースを表現
            - ユーザ登録、ユーザ覧表示など
        - handlerから呼びされる
            - 1つのhandlerに対応する専用usecaseが1つ存在します
        - 基本的にはdomainを触る
    
    - domain層
        - モデルレイヤでドメイン(システムが扱う業務領域)に関する値と振る舞いを持つ
        - 他のレイヤに依存しない
    
    - infrastructure層
        - 技術的関心ごとを扱うレイヤで具体的な技術に関する処理を書く
            - DBやMail操作など
        - 直接handler、usecaseから呼ばれることもあるが、基本的にdomainのインターフェースによって抽象化される
    
    - 参考文献
        - goで実装している
            - https://mintaku-blog.net/go-ddd/
            - https://qiita.com/tono-maron/items/345c433b86f74d314c8d
            - https://yyh-gl.github.io/tech-blog/blog/go_web_api/


        ![2020-11-13 4 50のイメージ (1)](https://user-images.githubusercontent.com/53253817/98988955-c4e4f600-256b-11eb-9638-f23c6d03b2ee.jpeg)

- DDDとユースケース図の関係
    - DDDで重要となるドメインの部分をユースケース図とドメインモデル図というもので決めれるらしい
        - これをユースケース駆動開発とか言われているらしい
        - UMLというのは組み合わせることで、新しい概念
    - https://logmi.jp/tech/articles/322835

- ちゃんとしたDDDの進め方(DDD固有のものは1-6だと思う。そのほかは一般的な開発の進め方)
    1. コンテキストモデル
    2. 要求モデル(要望の洗い出し)
    3. 要求モデル(要求の洗い出し)
    4. 要求モデル(要件の洗い出し)
    5. ドメインモデル
    6. ユースケースモデリング(ユースケース図)
    7. 画面設計(画面遷移図)
    8. 画面設計(ワイヤーフレーム)
    9. ユースケースモデリング(ユースケース記述)
    10. ロバストネス分析
    11. クラス図
    12. データモデリング(ER図)
    13. UI設計
    14. 実装に入る...
    - 参考文献
        - https://qiita.com/APPLE4869/items/d210ddc2cb1bfeea9338

- 大規模な開発
    - マイクロサービスでは、複数のアプリケーションを連携させて構築するが、一つ一つのアプリケーションはクリーンアーキテクチャなどを使って開発していくことになる

- あとで以下をしっかりまとめる
    - https://qiita.com/os1ma/items/7a229585ebdd8b7d86c2
    - https://qiita.com/tentom/items/653d46ded6e292630a6c
    - http://geekna.hatenablog.jp/entry/20110824/p1
    - https://www.yo1000.com/ddd-transcript
    - iosアプリをmvc,mvp,mvvm,clean-architectureで実装
        - https://medium.com/@rockname/clean-archirecture-7be37f34c943
    - レイヤードアーキテクチャにMVCを当てはめると
        - https://qiita.com/yuku_t/items/961194a5443b618a4cac
    - go言語でレイヤードアーキテクチャ+DDD
        - https://qiita.com/tono-maron/items/345c433b86f74d314c8d
---

