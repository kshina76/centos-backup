# アプリケーションアーキテクチャ
- アプリケーションアーキテクチャを実践に取り入れるときに考えることをまとめた

## アプリケーションアーキテクチャまとめ

- アーキテクチャの変遷
    1. Viewだけ
        - Viewにロジックなど何でも突っ込む構築
        - FatViewに陥る
    2. PDS(MVC)+2層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ユースケースを実行する場合はファサードを呼び出して、簡単なCRUDならそのままModelを呼び出す感じかな？
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - BusinessLogic層
            - サービスレイヤ
                - ファサード(facade)というデザインパターンを適用するための関数を定義してユースケースの役割を担わせる
                - ファサードは複数のビジネスロジックを順番に実行する関数
                - サービスレイヤはModelと同じpackageだけど、Modelのクラス内には定義しない(多分)。外部に関数として定義
            - Model
                - ビジネスロジック(データと振る舞い)を定義する
        - FatViewを解決するために考案
        - プレゼンテーション層とドメイン層を分離することが目的(詳しくはPDSの自分の解説)
        - MVCフレームワーク+ORMに沿って開発すると、このPDS(2層)を実現することになる
        - MVCフレームワークはVCとMの間にinterfaceを使うことで疎結合にしていると思われる(たぶん。推測。)
    3. PDS(MVC)+3層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ユースケースを実行する場合はファサードを呼び出して、簡単なCRUDならそのままModelを呼び出す感じかな？
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - BusinessLogic層
            - サービスレイヤ
                - ControllerとModelの密結合を回避するためのレイヤ(ユースケースを満たす役割)
                - ファサード(facade)というデザインパターンを適用するための関数を定義してユースケースの役割を担わせる
                - ファサードは複数のビジネスロジックを順番に実行する関数
                - サービスレイヤはModelと同じpackageだけど、Modelのクラス内には定義しない(多分)。外部に関数として定義
            - Model
                - ビジネスロジック(データと振る舞い)を定義する
        - DataAccess層
            - 2の概念にデータアクセス層が加わることで、生のSQLや外部APIを扱うことを容易にする
    4. PDS+4層
        - Presentation層
            - View
                - UIに関すること。templateエンジン、HTML、CSS、JS
            - Controller
                - ロジックはusecase層を呼び出すことで取得
                - WebアプリケーションではHTTP処理を行うレイヤ
                - リクエストを受けてテンプレートへレンダリング(Viewを呼び出すこと)、レスポンスを返す一連の流れを実装
                - 処理的なとこは、Get、Postパラメータの取得、リダイレクト処理などHTTP関連を扱う
                - ビジネスロジックはこのレイヤーでは定義せずHTTPの処理の流れのみがシンプルに確認できるようにする
        - Usecase層
            - 3のファサードを改めてここのusecase層に分離している
        - Domain層
            - ビジネスロジック(データと振る舞い)を定義する
        - DataAccess層
            - 生のSQLや外部APIを扱うことを容易にする
        - 3のBusinessLogicのサービスレイヤをusecase層として定義するアーキテクチャ
            - つまり、BusinessLogic層をUsecase層とDomain層に分割するということ
    5. PDS+DDD(3,4層)
        - DIPを使って依存関係を逆にする
    6. PDS+DDD(クリーンアーキテクチャ)
        - まだわかっていない
    7. DDD+CQRS
        - https://www.slideshare.net/mobile/dcubeio/ddd-cqrs-orm
    8. マイクロサービスアーキテクチャ
    9. その他のアーキテクチャなど
        - 40ページ目に色々載っている
            - https://www.slideshare.net/mobile/AtsuoAoki/ddd-201811
        - POSAに載っている色々なアーキテクチャ
            - https://qiita.com/y_ujitoko/items/aa82d3b49850e0bbca32
    - 注意点
        - レイヤードアーキテクチャは同一層同士は参照できる。だからMVCのVとC同士は参照できる
        - プロジェクトの規模によって選定して、やり過ぎたアーキテクチャを選定しないようにする
        - 純粋なレイヤードアーキテクチャを採用する時はusecaseとinfraの間でusecaseのmodelをinfraが参照しようとすると循環参照になってしまうので、DTOを使ってデータを伝搬させるようにする。DTOというのはData Transfer Objectというクラスで、データを変換したり交換する時に使用される。
            - go言語のcontextを全部のレイヤーでimportするとオブジェクトの交換でなくてもいける？？
    - 参考文献
        - MVCのベストプラクティス
            - https://rabbitfoot141.hatenablog.com/entry/2018/10/16/194555
        - FatController撲滅運動
            - https://www.slideshare.net/OhasiYuki/ss-52193845
        - webアプリケーションの設計パターン
            - http://blog.fujimisakari.com/web_application_architecture_pattern/

<br></br>

- アーキテクチャの変遷(条件を緩めたver)
    - リラックスレイヤシステム
        - http://yusuke-ujitoko.hatenablog.com/entry/2016/11/15/230224

## 実際に開発するときに見ること

- アーキテクチャの選択
    1. MVCフレームワークのORMで足りる
        - MVCフレームワークに沿って開発すれば良い(PDSの概念を取り入れるだけでいいということ)
    2. 複雑なDBのクエリを書くからORMでは足りない
        - PDSに加えてシステムアーキテクチャを取り入れる
            - 3層アーキテクチャ
                - infra層をusecase層から分離できるから、生のSQLを使ったプログラムでもコードをクリーンに保てる
            - 4層アーキテクチャ
                - usecase層からdomain層を分離できるので、usecase層が複雑になった場合などに有効
            - クリーンアーキテクチャ
                - あとで追記する

- レイヤードアーキテクチャ+DDDを実装するときに役に立つ図と解説
    - レイヤードアーキテクチャ(3層でも4層でも)を採用することで関心の未分離問題を解消
        - レイヤーを一つ飛ばしでアクセスしてしまう問題のこと
    - interfaceを使うことで密結合問題1を解消
        - 直接メソッドを呼び出してしまっている問題
        - 仕様変更に対応しやすい、機能追加がしやすい
        - Testable(単体テスト)なコードの実現
    - DI(Dependency Injection)を使うことで密結合問題2を解消
        - インスタンスを依存先のクラスで持ってしまっている問題
        - Testable(単体テスト)なコードの実現
    - DIPを使うことでdomain層とinfra層の依存関係を逆転
        - これはオプション
        - 変更されにくいdomain層を最下層に持っていける

    ![clean_architecture](https://user-images.githubusercontent.com/53253817/99709796-16006700-2ae3-11eb-8eab-8ac9c5445a54.png)

- わかったこと
    - interfaceとDIを使うことは必須
        - どちらもテスダブル(特に単体テスト)なコードを実現するのに必要
    - 3層、4層、クリーンなどのどれにするかは規模やチームによる
        - 個人開発の小規模なアプリケーションは3層で十分な気がしてきた
    - infra層のDIPはオプション
        - DDDを取り入れるならDIPを行う


---

## アプリケーションアーキテクチャを取り入れた開発をするときにわからなくなったら見ること

- PDS(presentation domain separation)
    - プレゼンテーション層とドメイン層を分離すること
        - プレゼンテーション層の設計にフォーカスしたもの。プレゼンテーション層に当てはまらない余り物をドメイン層に配置する
    - なぜプレゼンテーション層とドメインに分割するのか？
        - 関心の分離をすることが目的
        - プレゼンテーション層はコードによるテストが困難だから。他の層はカードによるテストで自動化したいから分離をしないと単体テストができない。
        - プレゼンテーション層は専門性が高いから分業する仕組みが欲しい
    - MVC,MVVM,MVPといった概念がこれにあたる
        - VCがプレゼンテーション層に。それ以外のものをMに詰め込んでドメイン層とする。

- アプリケーションアーキテクチャ
    - PDSだけではドメイン層(Model)が複雑になり過ぎてしまうから、さらに関心を分類することが必要になったことから生まれた
    - レイヤーアーキテクチャ(3層、ドメイン層をusecaseとinfraに関心を分離した)
        - presentation層
            - VCに当たる部分。UIを実現する。
        - usecase層
            - ビジネスロジック層。
            - 「ユースケース単位」でクラスを分割
                - ユースケース図に書かれた一つ一つがクラスに分割される
            - 重要なのはルールや制約も含まれること
        - infra層
            - 外部API通信、SQL発行
    - レイヤーアーキテクチャ(4層、usecase層からドメイン層を抜き出して関心を分離した)
        - presentation層
            - VCに当たる部分。UIを実現する
        - usecase層
            - 「ユースケース単位」でクラスを分割
                - ユースケース図に書かれた一つ一つがクラスに分割される
            - ルールや制約は含まない
        - domain層
            - ビジネスのルールや制約(メソッド、プロパティ)
            - アプリケーションの流れではなくて判定とかそっちのロジックが含まれる感じ
                - アプリケーションがなくても現実世界で存在するルール。アプリケーションがない世界でどのように実現するか考えた時のルールを考えるとdomain層に割り当てられるべきものがわかるかも
        - infra層
            - 外部API接続、SQL発行

- アーキテクチャの実装の遷移
    1. とりあえずレイヤーごとに分割して実装
        - 関心の未分離が問題
            - レイヤーを一つ飛ばしなどでアクセスしてしまっているということだと思う
    2. 飛ばして参照されている処理を違うレイヤーに移送して実装
        - レイヤー間が密結合な問題
            - レイヤー間で直接メソッドを参照している
    3. interfaceを使って利用者がinterfaceにのみ依存するよう実装
        - レイヤー間が密結合な問題2
            - インスタンスを生成する箇所がクラスに依存してしまっている
    4. DIまたはservice rocatorを使用

- 参考文献
- 色々なアーキテクチャ
https://qiita.com/YutoMizutani/items/260f684871b77732e18f

- なぜMVCが生まれたか
http://memowomome.hatenablog.com/entry/2014/04/13/102736

- interfaceを使う理由、レイヤーに分ける理由
https://www.slideshare.net/mobile/AtsushiNakamura4/ss-79365929

- 関心の分離
https://qiita.com/MinoDriven/items/37599172b2cd27c38a33

- ユースケース層とドメイン層の違い
https://little-hands.hatenablog.com/entry/2019/07/26/domain-knowledge