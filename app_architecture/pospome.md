# 技術書典5 pospomeサーバサイドアーキテクチャ
## わかったこと
### DTOの用途
- 依存関係を保つ
- 循環参照を無くす
- メソッド(関数)への引数が多くなってしまうことへの対処法
### 依存関係を定義するのに、必ずinterfaceを使うというわけではない
- 依存先のパッケージをimportすることで依存関係が定義される。interfaceを使うことで依存するわけではない。
- interfaceはDIパターンというテスタブルなコードを実現する方法を取り入れたいときに使われるもの
### ディレクトリ名とパッケージ名の統一
- presentionディレクトリ内にviewディレクトリを作った場合もviewディレクトリ内のファイルはviewパッケージにする
- presentationディレクトリ直下のファイルはpresentationパッケージにする
- golangだけなのか他の言語もそうなのかはわからない
### クラスとレイヤーの考え方
- クラスは似たような処理が集まったもので、変数をサブルーチン間で共有したいものが集まったものくらいに考えておくのがいい
- レイヤは、さらに似たクラスをレイヤごとに分けることで、一つ一つのレイヤを大きな一つのパッケージとして捉えるという考え方

---

<br></br>

## 1.Web アプリケーションにおけるレイヤ構造パターン集
### レイヤとは？
- レイヤ=パッケージ(モジュール)
  - ここでいうパッケージとは、Webアプリケーションにおいて普遍的な責務を持つパッケージ
- MVCパターンであれば、モデル、ビュー、コントローラーという3つのパッケージがレイヤとして存在
- ECサイトであれ、オークションサイトであれ、ドメインロジックを持つというモデルの責務が変わることはない(普遍的)
- そのため、常に使う側と使われる側の関係性が決まっている(レイヤ間は単方向依存である)のが特徴

<br></br>

### レイヤ構造のメリットとデメリット
#### 修正による影響範囲を予測することができる
- MVCの場合、「M <- C -> V」の依存件関係だから、Cの修正はMに影響があるが、Mの修正はCに影響がないといった感じ
- これがもっと大規模でぐちゃぐちゃの依存関係だったら予測が難しいのがわかる
#### どこにどのようなコードがあるのかが分かりやすい
- システムを修正するときにどのレイヤのコードを変更すればいいかわかる
- 実装者によるコードの置き場所のブレが少なくなる
#### コードのキャッチアップのイニシャルコストが下がる
- 自分が担当するサービスや部署が変わったとしてもレイヤ構造が同じであればキャッチアップ可能
#### パッケージ同士の依存を適切に保つことができる
- 誰もが適切にパッケージ同士の依存関係を定義できるわけではないから、レイヤ構造では最低限の秩序を守ることができる
#### 学習コストが高い(デメリット)
- レイヤ構造に対する知識がない場合、レイヤそれぞれの責務を覚える必要がある
#### コード量が多くなる傾向にある(デメリット)
- レイヤ構造の階層が多ければ多いほど、全体のコード量は増えてしまう傾向にある

<br></br>

### コントローラーパターン
- コントローラーパターンはMVCパターンのコントローラーに全てのロジックを実装するシンプルなパターン
- レイヤがコントローラーのみなので、一般的にはレイヤ構造とは認識されない
- 基本的にcontrollerパッケージ直下にファイルやパッケージを置く
- サーバの出力がHTMLの場合は、templateパッケージのようなHTMLのテンプレートを置く
#### メリット
- 学習コストがかからなく、すぐにコードがかける
#### デメリット
- コード量が増えると見通しが悪くなる
#### 使い所と特徴
- 開発作業に必要なデータを開発用DBに登録する
- 本番環境のサービス運用で必要なデータを本番DBに登録する
- サービスを利用するエンドユーザー向けの実装ではなく、社内でのサービス運用に利用する実装に使うことが多い
- 社内でのサービス運用では信頼性のあるデータがすでに存在していて、それをWebUIからDBに登録するだけという要件が多いので、コントローラーパターンで十分実装可能なことが多い
#### サンプル

```bash
# パッケージ構成
.
├── controller
│   └── user.go
├── main.go
└── templates
    └── user.html
```

```go
package controller

import (
    "fmt"
    "net/http"
)

func Handler(w http.ResponseWriter, r *http.Request) {
    //バリデーション
    n := r.FormValue("name")
    if n == "" {
        fmt.Fprint(w, "name error")
        return
    }
    //DB アクセス
    conn := db.NewConnection() conn.BeginTransaction()
    u := &User{
        Name: n,
    }
    if err := db.Insert(conn, u); err != nil { db.Rollback()
        fmt.Fprint(w, "db error")
        return
    } 
    conn.Commit()
    fmt.Fprint(w, "success")
}

type User struct {
    Name string
}
  
```

<br></br>

### MVCパターン
- コントローラーパターンにモデルレイヤとビューレイヤを追加したものがMVCパターン
- MVCパターンはフルスタックなフレームワークとして提供されていることが多く、それを利用する場合は実装者がcontroller,model,viewという3つのパッケージを用意する必要はないかも
#### 依存関係
- ViewからModelに依存しているのは、modelの構造体をviewから取得すると便利だから。構造体を展開してバラバラに渡すことで依存しなくなるが、引数が多い場合などに不便

![2020-12-07 14 36のイメージ](https://user-images.githubusercontent.com/53253817/101313487-8eb04300-3899-11eb-8341-bdde0fcb4e78.jpeg)

#### ビューレイヤ
- HTML, JSON など、サーバの出力に関するロジックを実装する責務を持つ
- Go言語の場合はHTMLを出力するのであればhtml/template パッケージ、JSONであればencoding/jsonパッケージが標準パッケージがある
#### コントローラーレイヤ
- HTTP,gRPCなどの入力を受けとり、それらをモデルレイヤ、ビューレイヤが利用可能な値に変換する。
- モデルを操作する。
- DBのトランザクションを制御する。
- ビューを操作し、HTML, JSON などのレスポンスを返す。
#### モデルレイヤ
- システム仕様に関するドメインロジックとDBアクセス、メール送信などの技術的なロジックを実装する責務を持つ。
- コントローラーレイヤとビューレイヤがある程度限られた責務しか持たないので、それらのレイヤに置くべきではないロジックは全てモデルレイヤに実装すると考えれば書きやすい
#### メリット
- ある程度の規模の開発にも耐えられる
#### デメリット
- コントローラーレイヤの見通しが悪くなる可能性がある
- 本来モデルレイヤやビューレイヤに実装するはずのロジックがコントローラーレイヤに実装されてしまう
  - ファットコントローラのアンチパターン
- モデルレイヤが肥大化する可能性がある
  - MVCパターンはモデルレイヤにドメインロジックと技術的なロジックを実装するから
  - go言語の場合、パッケージで名前空間が作られているから、同じパッケージだと強く依存してしまう。modelパッケージ内でさらにパッケージを分割することで対処する

  ```bash
  # 改善前
  model
  ├── db.go
  ├── mail.go
  ├── project.go
  ├── task.go
  └── user.go
  ```

  ```bash
  # 改善後
  model
  ├── db
  │   └── db.go
  ├── mail
  │   └── mail.go
  ├── project.go
  ├── task.go
  └── user.go
  ```

#### サンプル

```bash
# パッケージ構成
.
├── controller
│   └── user.go
├── main.go
├── model
│   ├── mail.go
│   └── user.go
└── view
    ├── templates
    │   └── user.html
    └── user.go
```

<br></br>

### MVC + サービスレイヤパターン
- サービスレイヤはコントローラーレイヤから呼び出されるレイヤで、モデルを操作して任意の処理を実行する責務を持つ
- ビューを操作することはない
- MVCのコントローラーが担当していた「モデルの操作」の責務をサービスレイヤに切り出したパターン
#### 依存関係

![2020-12-07 15 02のイメージ](https://user-images.githubusercontent.com/53253817/101315072-38450380-389d-11eb-9316-0ab11a86cfb7.jpeg)

#### サービスレイヤ
- モデルを操作しているロジックだけ切り出す
- 入力値の加工と出力はコントローラーの責務なので、サービスレイヤには切り出さない
  - モデルの責務ではないから
#### メリット
- コントローラーレイヤの見通しが良くなる
- 任意のタイミングでサービスレイヤを導入できる
  - コントローラーレイヤの一部のロジックを切り出すだけだから、MVCパターンから簡単に移行できる
#### デメリット
- 実装者によってサービスの実装方法が異なる場合がある
- サービスレイヤが過度に肥大化する可能性がある
#### サンプル

```bash
# パッケージ構成
test
├── controller
│   └── user.go
├── main.go
├── model
│   ├── mail.go
│   └── user.go
├── service
│   └── user.go
└── view
    ├── templates
    │   └── user.html
    └── user.go
```

### サービスレイヤの実装方法
#### 単一サービス方式
- コントローラーとサービスが一対一で結びつく方式
- コントローラーの関数が二つなら、サービスも二つの関数で実装される
- サービスが共通する場合は、まとめて共通化する
- コントローラーは自分に適切なサービスを呼び出すだけだから、サービスの実装は知らなくていい
- 引数が多い場合はDTOにまとめて行う
#### 複数サービス方式
- 一つのコントローラーが複数のサービスを呼び出す方式
- 複数のサービスを呼ぶので、DBのトランザクション制御はコントローラーで行う必要がある
- 使い方としては、コントローラーの中の見通しが悪いところをサービスとして切り出すという方法なので、切り出し方は比較的自由

<br></br>

### 純粋なレイヤードアーキテクチャ
- 「MVC+サービスレイヤパターン」にインフラレイヤを追加したパターンのようなもの
- 依存は直下のレイヤである必要はない
  - だからといって依存関係を多くするのは好ましくないので、できるだけ少なくする

#### 依存関係

![2020-12-07 15 31のイメージ](https://user-images.githubusercontent.com/53253817/101317173-53b20d80-38a1-11eb-926f-c705cbfb8f56.jpeg)

#### プレゼンテーションレイヤ
- MVCのコントローラーレイヤとビューレイヤを合わせたレイヤ
- プレゼンテーションレイヤ内では、コントローラとビューでパッケージを分けることが多い
#### アプリケーションレイヤ
- ドメインレイヤのオブジェクトとインフラレイヤのオブジェクトを操作して任意のビジネスロジックを実行する責務を持つ
- データの整合性を保つトランザクションはアプリケーションレイヤが制御
- MVC+サービスレイヤパターンにおけるサービスレイヤの単一サービス方式に相当するレイヤ
#### ドメインレイヤ
- ドメインロジックを実装する責務
- MVCパターンのモデルと責務が似ているが、DBアクセスやメール送信などの技術的な実装は持たない
- 技術面の実装はインフラストラクチャレイヤが担当
#### インフラストラクチャレイヤ
- DBアクセスやメール送信などの具体的なロジックを持つ
- 全てのレイヤはインフラストラクチャレイヤに依存する可能性があるが、その逆は依存しない
  - レイヤードアーキテクチャはインフラストラクチャレイヤを中心にしたレイヤ構造
  - つまりレイヤードアーキテクチャは技術駆動のレイヤ構造と見なせる
  - DIPを使うとドメインが中心になるので、ドメイン駆動になる
#### なぜインフラストラクチャレイヤを切り出す必要があったのか？
- MVCパターンにインフラストラクチャレイヤがない理由
  - 実際の開発においてMVCパターンを導入する場合、フルスタックなMVCフレームワークが利用されることが多いので、フルスクラッチで実装することは少ない
  - フレームワークはRDBへのORMやメール送信など、それなりに技術的な実装を備えているので、MVCパターンではフレームワークがレイヤードアーキテクチャにおけるインフラストラクチャレイヤに相当する
  - そのため MVCパターンでは明示的にインフラストラクチャレイヤを置く必要がなかった
- レイヤードアーキテクチャにインフラストラクチャレイヤがある理由
  - RDBとNoSQLのように複数の永続化手段や、いろいろな外部APIの呼び出しなど技術が多様化してきたから

#### サンプル

```bash
# パッケージ構成
test
├── application
│   └── user.go
├── domain
│   └── user.go
├── infra
│   └── db.go
└── presentation
    ├── controller
    │   └── user.go
    └── view
        ├── templates
        │   └── user.html
        └── user.go
```

<br></br>

### 厳格なレイヤードアーキテクチャ
#### 依存関係

#### 依存関係の保ち方
- 実装のポイントはインフラストラクチャレイヤの引数と戻り値をドメインレイヤに依存させないこと(引数と戻り値は以下のどれかのパターンになる)
  1. int,string のようなプリミティブな値
  2. インフラストラクチャレイヤで定義しているDTO
  3. 標準パッケージやライブラリが提供しているオブジェクト
    - DBのコネクションのオブジェクトなどがこれにあたる。要は外部ライブラリで実装されているもの

<br></br>

### アプリケーションレイヤをインフラストラクチャレイヤに依存させるレイヤードアーキテクチャ

#### メリット
- ドメインレイヤーがインフラストラクチャレイヤの呼び出しが要らなくなるので(多分)、コネクションの変数などを引数に使わなくて良くなる

<br></br>

### ヘキサゴナルアーキテクチャ

<br></br>

### クリーンアーキテクチャ

<br></br>

### レイヤードアーキテクチャ+ポートパターン
#### インフラストラクチャレイヤーにポートを定義する

#### ドメインレイヤにポートを定義する
- よく見るDIPを使ったパターンのこと

---

<br></br>

## Go言語におけるWebアプリケーションのパッケージ構成

### レイヤ構造パターン
- 今まで学習してきたパッケージ構成のことなので割愛

### フラットパッケージパターン

### シングルパッケージパターン
