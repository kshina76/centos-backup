# Web API The Good Parts 書籍メモ

## 0. 自分のメモ
### Swagger
- OpenAPIとSwagger
  - OpenAPIとは、RESTful APIを記述するためのフォーマットのこと
  - Swaggerとは、OpenAPIを用いてREST APIを設計する際に使用するツールセットのこと
  - つまり、Swaggerというツール群を使用することで、OpenAPIの仕様に則ったドキュメントを作成できるということ
  - Swaggerはドキュメントだけでなくて、サーバとクライアントのコードを生成することもできる

  ![2020-11-30 23 49のイメージ](https://user-images.githubusercontent.com/53253817/102111962-636dbb00-3e7a-11eb-9d7e-cdb2c48ef8da.jpeg)

- スキーマ駆動開発
  - Swaggerを利用すると、スキーマ駆動開発といってURI設計やデータを決めてからドキュメントから自動でAPIのコードを生成するという順番で開発をしていくことができる

#### Swaggerの便利ツール
- yamlを書かなくてもよくなったり色々
- https://future-architect.github.io/articles/20191008/
- https://future-architect.github.io/articles/20200630/

#### 参考文献
- swaggerの紹介
  - https://www.slideshare.net/TakuroWada/openapipythonweb
  - https://qiita.com/teinen_qiita/items/e440ca7b1b52ec918f1b

### 0-2. WebAPIは公開していなくても解析されてバレる
- WebAPIがどのようなものか知っていたら簡単にバレる
- https://note.com/plusl/n/n52a673b95a1f

## 1.Web APIとは何か
### Web API
- HTTPプロトコルを利用してネットワーク越しに呼び出すAPI
- プロトコルがHTTPなので、エンドポイントはURIを指定して呼び出す
- 機械的にアクセスしてデータを得るものなので、人間がブラウザにアクセスしたりクリックしたりして使うものではない
### API
- ソフトウェアコンポーネントの外部インタフェース
- 機能はわかっているが、その中身の詳しい動作はわからない(知らなくても良い)機能のかたまり

### 1-2.Web APIのパターン
- 公開しているウェブサービスのデータや機能のAPI公開
  - Programmable Webというサイトで色々な企業のAPIが公開されている
- 他のページに貼り付けるウィジェットの構築
  - Amazonで公開している自社の商品ページを、自分のサイトに貼り付けたりするパターンのAPI
  - AmazonやFaceBookが提供しているJavaScriptのコードを自分のサイトに貼り付けるだけで実装できる
  - ブラウザにJavaScriptのコードを埋め込むから、何をしているかわかってしまうので、悪用される可能性は増える
- モダンなwebアプリケーションの構築
  - SPAのように、ページを読み込むのと別のタイミングで情報を取得してレンダリングするのに使うAPI
  - 一般的な方法は、JavaScriptのAJAXを使ってAPIを叩くことで、データを取得する
  - ブラウザにJavaScriptのコードを埋め込むから、何をしているかわかってしまうので、悪用される可能性が増える
- スマートフォンアプリケーションの開発
  - クライアントとサーバの間をのAPIを開発するパターン
  - ブラウザほど悪用することは簡単ではないが、スマホとサーバの間の通信を盗聴すればわかってしまうので、注意が必要
- ソーシャルゲームの開発
  - 他の人と協力して行うといった性質なのでサーバ側にデータを保存する必要があるから、APIが使われる
  - MMORPGほどのリアルタイム性はいらないから、手軽なAPIが使われることが多い
  - チートされないような設計にする必要がある
- 社内システムの連携
  - 各システムの連携をWebAPIを使って疎結合にすることで、変更に強いシステムにできるから、APIが使われる

### 1-3.何をAPIで公開するべきか
- 「そのwebサービスで行える全ての機能」または「コアとなるサービスの機能」
  - 例えば、ECサイトなら「商品の検索」や「商品の購入」といった機能

### 1-4.WebAPIを美しく設計する重要性
- 使いやすい
- 変更しやすい
- 頑強である
- 恥ずかしくない

### 1-6.RESTという言葉は曖昧
- WebベースのAPIを何でもかんでもRESTと呼んでいたりするから、そこまでRESTという言葉にこだわりすぎない方がいいかも

<br></br>

## 2.エンドポイントの設計とリクエストの形式

### 2-1.APIとして公開する機能を設計する
- まず自分のサービスに対して、どのパターンのWebAPIを作成するかを決める(例えば以下の二つのAPIを開発することを考える)
  - モバイルアプリのバックエンドとしてのAPI
  - 公開用のAPI

- モバイルアプリのバックエンドのAPI
  1. クライアントの画面遷移図を作る
  2. 1を参考にしながらユースケース図に落とし込む

### 2-2.APIエンドポイントの設計
#### 2-2-0. 大前提
- WebAPIの場合は、URIを設計することと同値
- 前提として「覚えやすく、どんな機能を持つURIなのかが一目で判断できるようなもの」を考える
#### 2-2-1.短く入力しやすいURI

```bash
# 悪い例...apiという文字がかぶっている。serviceは他のAPIと被ってしまいそう
http://api.example.com/service/api/search

# 良い例...検索のAPIであることが見てわかる
http://api.example.com/serach
```

#### 2-2-2.人間が読んで理解できるURI
- productsをprodのように略してはだめ
- 英語を使うようにする
  - findよりsearchを使う。というようにAPIではどのような単語が一般的かを知る必要がある
  - Programmable APIというサイトでどのような単語が使われているかを勉強するのがいい(Qiitaの記事に出来そう)
  - https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923

```bash
# 悪い例
http://api.example.com/sv/u

# 良い例
http://api.example.com/products/12345
```

#### 2-2-3.大文字小文字が混在していないURI
- 大文字と小文字は区別するようにする
  - 本来はusersだけど、Usersでアクセスが来た場合はNot Foundで返すのが一般的

```bash
# 悪い例
http://api.example.com/Users/12345

# 良い例
http://api.example.com/users/12345
```

#### 2-2-4.改造しやすいURI
- idを変えれば違うuserにアクセスできるとわかるようなURI
- するべきではないという主張もあるが、とりあえずこのようなURIにするべきだと思う

```bash
# 良い例
http://api.example.com/users/12345
```

#### 2-2-5.サーバ側のアーキテクチャが反映されていないURI
- どんな言語を使っているか、サーバサイドのディレクトリやシステム構成がどのようになっているかといったことを意識させない

```bash
# 悪い例...phpを使ってCGIとして動作しているということがわかってしまう
http://api.example.com/cgi-bin/get_user.php?user=100
```

#### 2-2-6.ルールが統一されたURI

```bash
# 悪い例
http://api.example.com/friends?id=100
http://api.example.com/friend/100/message

# 良い例
http://api.example.com/friends/100
http://api.example.com/friends/100/message

```

### 2-3.HTTPメソッドとエンドポイント
- メソッド...リソースに対して何をするか
- URI...リソース
- WebアプリのformではGETとPOSTしか使えないが、WebAPIでは様々なメソッドが用意されているので、それらを駆使する

#### 2-3-1. GET...リソースの取得
- URIで指定されたリソースを取得する

#### 2-3-2. POST...リソースの新規登録
- 指定したURIに属する新しいリソースを送信する
  - 簡単に言うと、新しい情報を登録するために使う
- 「リソースを送信すること」ではないので注意
  - リソースを送信して既存のリソースを置き換えるというのはPUTというメソッドが存在するから

#### 2-3-3. PUT...既存リソースの更新
- 既存のリソースを完全に上書きする

```bash
# POST
http://api.example.com/v1/friends
|
| POST(新規作成)
↓
http://api.example.com/v1/friends/12345

# PUT
http://api.example.com/v1/friends/12345
|
| PUT(置き換える)
↓
http://api.example.com/v1/friends/12345
```

#### 2-3-4. PATCH...リソースの一部変更
- 既存のリソースの一部を置き換える

#### 2-3-5. DELETE...リソースの削除
- 既存のリソースの削除をする

#### 2-3-6. HEAD...リソースのメタ情報の取得

### GETとPOSTしか使えない環境の場合はどうするか
- 例えばFlaskではPUTとして実装するが、ブラウザからはFormで実装しているからPOSTで飛ばさないといけないといったことがある
#### X-HTTP-Method-Overrideヘッダを使う方法
- リクエストの際に、X-HTTP-Method-OverrideヘッダにPUTを指定しておくと、APIのサーバがPUTでリクエストが来たと見なしてくれる
- こっちが一般的な方法
#### _Methodを使う方法

### 2-4.APIのエンドポイント設計
- リソースを集合論に当てはめて設計していく
- 「あるデータの集合」と「個々のデータ」の二種類に分類して、HTTPメソッドを適用していく
  - DBでいうとテーブルとレコードの関係を意識する
  - 以下の例だと、エンドポイントが二種類に分類できていることがわかる
- バージョンはURIに含めてしまうのがいい

| 目的                     | エンドポイント                      | メソッド  | 
| ------------------------ | ----------------------------------- | --------- | 
| ユーザ一覧取得           | http://api.example.com/v1/users     | GET       | 
| ユーザの新規登録         | http://api.example.com/v1/users     | POST      | 
| 特定のユーザの情報の取得 | http://api.example.com/v1/users/:id | GET       | 
| ユーザの情報の更新       | http://api.example.com/v1/users/:id | PUT/PATCH | 
| ユーザの情報の削除       | http://api.example.com/v1/users/:id | DELETE    | 

| 目的                 | エンドポイント                                  | メソッド | 
| -------------------- | ----------------------------------------------- | -------- | 
| ユーザの友達一覧取得 | http://api.example.com/v1/users/:id/friends     | GET      | 
| 友達の追加           | http://api.example.com/v1/users/:id/friends     | POST     | 
| 友達の削除           | http://api.example.com/v1/users/:id/friends/:id | DELETE   | 

| 目的                   | エンドポイント                                      | メソッド | 
| ---------------------- | --------------------------------------------------- | -------- | 
| 近況の編集             | http://api.example.com/v1/updates/:id               | PUT      | 
| 近況の削除             | http://api.example.com/v1/updates/:id               | DELETE   | 
| 近況の投稿             | http://api.example.com/v1/updates                   | POST     | 
| 特定ユーザの近況の取得 | http://api.example.com/v1/users/:id/updates         | GET      | 
| 友達の近況一覧の取得   | http://api.example.com/v1/usres/:id/friends/updates | GET      | 

#### 2-4-1. エンドポイント設計の注意点
- 複数系の名詞に気を付ける
  - 「集合」を表すものは複数形にするべき
  - 複数形になることで大きく変わるものにも注意...media->mediumとか
- 動詞はメソッドが担うので、リソースは名詞に徹する
- 利用する単語に気を付ける
  - findではなくてsearchなど
- スペースやエンコードを必要とする文字を使わない
  - パーセントエンコーディングされてしまうため
- 単語をつなげる必要がある場合はハイフンを利用する
  - スパイナルケース、チェインケース
    - profile-image
  - スネークケース
    - profile_image
  - キャメルケース
    - profileImage

#### 2-4-2. CRUDの概念にフィットしないようなアクションについてどうするか
- 参考文献
  - https://qiita.com/mserizawa/items/b833e407d89abd21ee72

> 1つは、アクションをリソースの項目の1つとして扱う方法で、これはアクションがパラメータを取らない場合に有効です。例えば、何かをアクティベートするようなアクションであれば、対象となる boolean 項目をサブリソースとして扱って、そこに対して PATCH リクエストを投げると考えます。GitHub API の例を見てみましょう。Gist にスターをつけるアクションを PUT /gists/:id/star としていて、スターを解除するアクションを DELETE /gists/:id/star としています。

> 一方で、REST の構造にマッチさせられないアクションもあると思います。例えば、複数のリソースを横断的に検索するようなアクションについては、特定リソースのエンドポイントに紐付けるのは、なんとも無理やりな感じがします。このような場合は、/search というエンドポイントを作ることで解決します。ちょっとルール違反な気もしますが、API 利用者から見ておかしくなく、混乱がないようにドキュメントにしっかりと書かれていれば問題ないのです。

### 2-5.検索とクエリパラメータの設計

#### 1.取得数と取得位置のクエリパラメータ...ページネーションの仕組みを提供するため
- page/per_page...自由度が低い
  - pageは取得するページ番号、per_pageは1ページあたりのアイテム数
  - per_page=50&page=3
    - 101番目から150番目までのアイテムを取得する

- offset/limit...自由度が高い(好まれる)
  - offsetは0から数えた時のアイテム番号、limitは1ページあたりのアイテム数
  - offset=100&limit=50
    - 101番目から150番目までのアイテムを取得する

- 相対位置を使用する際の問題点
  - データ数が増えるとパフォーマンスが悪い
    - 一件目から順番に検索するから
  - データに不整合が生じる可能性がある

- 絶対位置でデータを取得する

#### 2.絞り込みのためのパラメータ
- qはフィールドが一つの時、部分一致の検索をするときに使う
- searchを使っている理由は、量が多すぎて一覧は取ってこれないけど、検索をするapiですよということを表したい場合は有効

```
http://api.linkedin.com/v1/people-search?first-name=Clair

http://api.instagram.com/v1/users/search?q=jack
```

#### 3.クエリパラメータとパスの使い分け(リクエスト)
1. クエリストリングに含める
  - 何らかのリソースのフィルタリング、ソート、ページングを実現したいときに使う

```bash
# 検索
curl localhost:3000/items?name=hoge
# ソート
curl localhost:3000/items?sort_by=price&order=asc
# ページング
curl localhost:3000/items?page=3&limit=50
```

2. リクエストボディに含める
  - リソースの作成や更新で必要な情報はここに入れる
  - ユーザーの入力値とか

```bash
# 作成
curl -X POST localhost:3000/items -d '{"name": "hoge", "price": 200}'
# 更新
curl -X PUT localhost:3000/items/1 -d '{"name": "fuga", "price": 400}'
curl -X PATCH localhost:3000/items/1 -d '{"price": 500}'
```

3. パスに含める
  - 一意にリソースを特定できる識別子は必ずパスに含める
  - IDとか商品コードとか注文番号とか
  - 逆に複数リソースが該当する可能性がある場合は含めるべきではない

```bash
# 商品コードABC-123の商品の情報を取得する
curl localhost:3000/items/ABC-123
# 注文番号O-1239の注文のステータスを更新する
curl -X PATCH localhost:3000/orders/O-1239 -d '{"status": "delivered"}'
```

4. まとめると

```ruby
if param == "一意にリソースを特定できるユニークな識別子である"
  # => パス
elsif param == "リソースを作成または更新する際の、リソースの情報/状態を表す値である"
  # => リクエストボディ
elsif param == "リソースのフィルタリング/ソート/ページングを表す"
  # => クエリストリング
elsif param == "認証情報である"
  # => クエリストリング または ヘッダー
elsif param == "コンテンツのデータには直接関係しないメタ情報である"
  # => ヘッダー
end
```

- 参考文献
  - https://qiita.com/sakuraya/items/6f1030279a747bcce648

### 2-6. フィルタ・ソート・検索はリクエストパラメータでやろう
ベースとなる URL はできるだけシンプルにしておくのが良いです。フィルタやソート、検索といった機能はリクエストパラメータで制御するのが良いです（もっとも、これは単一リソースに対するものに限ります）。これらについて、細かく見ていきましょう。
#### 2-6-1. フィルタリング
各フィールドに対して、フィルタリングをするためのパラメータを用意しましょう。例えば、`/tickets`でチケットのリストを取得する際に、state が open のものだけに絞りたいことがあると思います。このような要望は`GET /tickets?state=open`のようにして実現させましょう。リソースの項目である`state`をそのまま、フィルタするためのリクエストパラメータとするのです。
#### 2-6-2. ソート
並び順の指定については、`sort`パラメータを用意して処理するようにしましょう。複雑なソートにも応えられるように、ソート対象とする項目をカンマ区切りで指定して、かつ、昇順・降順をネガポジで指定するようにします。いくつか例を挙げてみます。
`GET /tickets?sort=-priority` - チケットのリストを priority の降順で取得する
`GET /tickets?sort=-priority,created_at` - チケットのリストを priority の降順、かつ created_at の昇順で取得する
#### 2-6-3. 検索
フィルタクエリでは事足りず、全文検索が必要になることもあると思います。おそらく、ElasticSearch や他の Lucene ベースの検索エンジンを使うことになると思いますが、特定リソースに対して投げるクエリには、q パラメータを使いましょう。検索クエリはそのまま全文検索エンジンに伝えられ、API のアウトプットは普段と変わらない形式となります。
- 以上を組み合わせてみると、以下のような感じでリクエストパラメータが構築できます。
`GET /tickets?sort=-updated_at` - 最近更新されたチケットを取得する
`GET /tickets?state=closed&sort=-updated_at` - 最近クローズされたチケットを取得する
`GET /tickets?q=return&state=open&sort=-priority,created_at` - オープン状態で優先度の高いチケットのうち、「return」という単語を含むものを返す
#### 2-6-4. よく使うクエリのエイリアス
API の UX をより良くするために、よく使われる検索クエリは REST のパスにしてしまうことを考えましょう。例えば、「最近クローズされたチケット」を取得するクエリは、以下のような URL にまとめることができます。
`GET /tickets/recently_closed`

### 2-7. レスポンスのフィールドを絞れるようにしよう
- API 利用者は、常にリソースの全項目を必要としているわけではない
- レスポンスのフィールドを絞る手段を用意することは、API 利用者のネットワーク負荷を下げ、通信速度を向上させることに貢献する
- そのために、出力したいフィールドをカンマ区切りで指定できるパラメータを用意する
  - 例えば、以下のリクエストではオープン状態のチケットを更新日付順で並べて表示するのに必要な、最低限の情報のみを返す
`GET /tickets?fields=id,subject,customer_name,updated_at&state=open&sort=-updated_at`
#### 2-7-1. レスポンスグループ
- レスポンスのフィールドをまとめて提供する方法
- AmazonのProduct Advertising APIはSmall,Medium,Largeの3つに分けてそれぞれが取得できるフィールドの範囲を決めて提供している

### 2-8. 作成・更新の後は変更後の情報をフルで返そう
- POST, PATCH, PUT リクエストのレスポンスには変更後のリソースの情報を含める
  - API利用者が作成・更新後のリソース情報を取得するためにもう一度 API を叩くのは大変だから
- created_at や updated_at といった項目は、こちらが明示的に指定するものではなく、作成・更新の際にサーバが自動で挿入するもの
- なお、POST で新しくリソースを作成した際には、ステータスコード 201 を返し、Location ヘッダに作成されたリソースへの URL を含めるのが良い
  - Locationヘッダはリダイレクトに使うもの

### 2-9.ログインとOAuth2.0
- P49-57とqiitaとかを参考にして載せる
  - oauthにも色々な種類がある？あとで本からまとめる

#### WebAPI認証方式パターン
1. 標準化されたHTTP認証方式

2. APIキー認証

3. Form認証、アクセストークン認証

- OAuthの間違いやすい点
  - OAuthは認可をする仕組み
  - Bearerは認証をする仕組み
  - OAuthで認可をしてトークンを受け取り、Bearerでそのトークンを使って認証をする
  - AWS Cogniteは認可サーバの役割を担う

- 参考文献
  - https://architecting.hateblo.jp/entry/2020/03/27/033758

#### OAuthの説明

![https---qiita-image-store s3 amazonaws com-0-106044-d9119f21-736d-d5ed-964d-3068af0fcde9](https://user-images.githubusercontent.com/53253817/101063729-7eb50c80-35d6-11eb-8199-76d16868daab.png)

![https---qiita-image-store s3 amazonaws com-0-106044-f8dc0cca-15c1-569d-c6e4-2055ea8c97cb](https://user-images.githubusercontent.com/53253817/101062668-45c86800-35d5-11eb-8606-857e616ed3d5.png)

![https---qiita-image-store s3 amazonaws com-0-106044-319dd4e8-72b7-1af2-8bed-645120196b47](https://user-images.githubusercontent.com/53253817/101062672-46f99500-35d5-11eb-8f11-11282b19d5ae.png)

- 参考文献
  - https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be

### 2-10.適切なホスト名
- api.example.com

### 2-11.SSKDsとAPIデザイン
- 誰が使うかわからない公開するAPIはきれいに作る必要がある
- モバイルアプリのバックエンドといった、内部の開発者しか使わない場合は綺麗さより、ユーザ体験を優先するべき
  - 例えば、「新着の商品」「人気の商品」「ログイン中のユーザ情報」などといったものを個別で用意するのではなくて、「初期画面」というAPIを作って一回のAPI通信で取得できるようにしたほうが、画面を一気に描画できるし、速度も上がってユーザ体験が上がる。

### 2-12.HATEOASとREST LEVEL3 API
- HATEOASの導入は少し待つ

| 目的        | エンドポイント                              | 
| ----------- | ------------------------------------------- | 
| REST LEVEL0 | HTTPを使っている                            | 
| REST LEVEL1 | リソースの概念の導入                        | 
| REST LEVEL2 | HTTPの動詞（GET/POST/PUT/DELETEなど）の導入 | 
| REST LEVEL3 | HATEOASの導入                               | 

<br></br>

## 3.レスポンスデータの設計

### 3-1.データフォーマット
- JSON、XMLなど

#### 3-1-1. データフォーマットの指定方法
1. クエリパラメータを使う方法
  - 一番わかりやすい方法で、一番採用されている

```
http://api.example.com/v1/users?format=xml
```

2. 拡張子を使う方法

```
http://api.example.com/v1/users.json
```

3. リクエストヘッダでメディアタイプを指定する方法
  - Acceptヘッダで指定する方法
  - Acceptヘッダは複数行にわたって指定できる

```
GET /v1/users
HOST: api.exmaple.com
Accept: application.json
```

- どれがいいのか？
  - 一つだけサポートするなら1の方法
  - 複数サポートするなら1,3の方法

### 3-2.JSONPとXHTTPRequest(P69)
- P69~74に解説が書いてある
#### 3-2-1. JSONPをサポートするべきか？
- セキュリティ的にリスクがあるからしなくてもいい

### 3-3. データの内部構造の考え方
- 友達の一覧を取得するときにIDの一覧だけを返してしまうと、利便性に欠ける
  - IDを使ってもう一回リクエストを送って詳細を取得するなどをすることになるが、複数回のリクエストが発生することによって通信のトラフィックが増大してしまうのでよくない
- id,name,profile_icon...のように全ての情報を返してあげるといい
- 「2-7」で紹介したように、レスポンスのフィールドは絞れるようにした設計が一番いい
  - fieldsで指定して、省略されていたら全て返すという設計
  - `GET /tickets?fields=id,subject,customer_name,updated_at&state=open&sort=-updated_at`

#### 3-3-2. ヘッダーなどのメタ情報はボディに含めない
- HTTPヘッダーはリクエストやレスポンスの中のヘッダー部分に記述されているのだから、JSONで包まなくても取得できるので必要ない
- HTTPレスポンスのボディにはデータだけを返すようにする
- 無駄な容量を通信させないようになる
- 参考文献
  - https://qiita.com/mserizawa/items/b833e407d89abd21ee72#要素はラップせずに返そう

#### 3-3-3. データを階層構造にするかフラットにするか
- なるべくフラットにしたほうがいいけど、階層構造にしたほうがいい場合もあるので、ケースバイケース

#### 3-3-4. トップレベルの部分は配列とオブジェクトどちらにするか(P81,82)
- 筆者的にはオブジェクトにしたほうがいいらしい
  - レスポンスデータが何を表しているのかがわかりやすくなる
    - 配列の場合`[0]`のようにして取得をしなくてはいけないからわかりにくい
  - レスポンスデータをオブジェクトに統一することができる
    - for文で回して共通の処理をするときに面倒な場合があるから
  - セキュリティ上のリスクを避けることができる
    - トップレベルが配列だと「JSONインジェクション」という脆弱性がある

#### 3-3-5. 配列の件数、あるいは続きがあるかをどう返すべきか
- 配列の件数を取得するのは重い処理なので、無駄が多い
- 例えば10件の取得をするようなリクエストがされた時を考える(以下のような処理で件数を取得しなくても済む)
  1. サーバ側では11件目まで取得する
  2. 取得できたら1件削除して、hasHextをTrueにしてJSONに格納する

### 3-4. レスポンスデータのフォーマット
#### 3-4-1. 各データの名前
- 多くのAPIで同じ意味に利用されている一般的な単語を用いる
- よく使われている単語を全く別の意味で使わない
- なるべく少ない単語数で表現する
- 複数の単語を連結する場合、その連結方法はAPI全体を通して統一する
- 変な省略形は極力利用しない
- 単数形/複数形に気を付ける
  - 配列なら複数、それ以外は単数
- キャメルケースかスネークケースを使う
  - JSONに沿うならキャメルケース
  - 見やすさ重視ならスネークケース
#### 3-4-2. 性別のデータをどう表すか
- sexならmale,female
- genderなら色々あるので、数値で表現する場合もある
#### 3-4-3. 日付のフォーマット
- RFC3339を使用するのがいい
#### 3-4-4. 大きな整数とJSON
- 大きな整数をレスポンスで返すときにはstring型で返すようにする
  - 整数で返してしまうと、桁溢れなどの問題が出てきてしまう可能性があるから

### 3-6. エラーの表現
- クライアントに「エラーが発生しました」という文面だけだと、どのように対応していいのか分からずに不親切なので、ここの設計はしっかりやる
#### 3-6-1. ステータスコードでエラーを表現する
- 100番台 : 情報
- 200番台 : 成功
- 300番台 : リダイレクト
- 400番台 : クライアントサイドに起因するエラー
- 500番台 : サーバサイドに起因するエラー
- ぴったりくるステータスコードがなければ、200や300のように00で終わるステータスコードを返すようにする
  - 例えばデータの生成に関するステータスコードは201 Createdなどのように決まっているものがあるが、全てがぴったり行くわけではないので。
#### 3-6-2. エラーの詳細をクライアントに返す
- 404 Not Foundでも、何がなかったのかわからなかったり、400に関しては何が起きたかもよくわからないのでエラーとしては不十分
- 大きく分けて二つの方法がある
  - 独自定義のヘッダーをレスポンスヘッダーに入れるパターン

    ```
    X-MYNAME-ERROR-CODE: 2013
    X-MYNAME-ERROR-MESSAGE: Bad authentication token
    X-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication
    ```
  
  - レスポンスボディに入れるパターン
    - 以下のようにJSONのレスポンスボディとして、エラーの際の専用のデータ構造を用意して、そこにエラーを入れる

    ```json
    {
      "error": {
        "code": 2013,
        "message": "Bad authentication token",
        "info": "http://docs.example.com/api/v1/authentication"
      }
    }
    ```

- 推奨される方法は、レスポンスボディに入れるパターン
  - クライアントがメッセージを処理しやすいから
  
#### 3-6-3. エラー詳細情報には何を入れるべきか
- 独自のエラーコードを一桁増やして定義して、1000番台は汎用的なエラー、2000番台はユーザ情報のエラー、のようにステータスコードと同様のカテゴリ分けをすると管理がしやすい
- 開発者向けエラーメッセージと非開発者向けメッセージを分けるようなデータ構造を定義する場合もある

  ```json
  {
    "error": {
      "developerMessage": "開発者向けエラーメッセージ",
      "userMessage": "非開発者向けエラ〜メッセージ",
      "code": 2013,
      "info": "http://docs.example.com/api/v1/authentication"
    }
  }
  ```

#### 3-6-4. エラーの際にHTMLが返ることを防ぐ
- APIの開発に利用しているwebサーバやフレームワークなどが、エラーをHTMLで返すようなものを使っている場合は気を付ける
#### 3-6-5. メンテナンスとステータスコード
- 止むを得ない場合にメンテナンスをするときには503というステータスコードを使う
- モンゴメリー・スコットという開発者は、常に長めにメンテナンス時間を伝えて、早く終わらせることで有能に見せていた

<br></br>

## 4. HTTPの仕様を最大限利用する
### 4-1 ~ 4-2. それぞれのステータスコードの詳細の説明

### 4-3. キャッシュとHTTPの仕様
- リバースプロキシでキャッシュしている情報が古い情報になってしまう可能性などがある
- オリジンサーバでキャッシュコントロールをすることで、リバースプロキシのサーバに古い情報が残るなどを減らすようにする
#### 4-3-1. 期限切れモデル
- オリジンサーバからのレスポンスを受け取った時の情報だけを元にキャッシュの保持時間を決める
  - レスポンスを受け取る側はリバースプロキシなどのキャッシュをするサーバ視点で話している
- キャッシュされたデータが新しいものなのかを判定するための2種類の方法
  1. Expiresヘッダーを使用する方法
    - 絶対時間を指定して、その時間を過ぎたら新鮮でないデータとして扱う
    - 特定の時刻に更新することがわかっているデータはこの方法で指定する
      - 例えば、一日ごとの天気の情報とか
    - または、更新される予定がない情報などは、遠い日付を指定しておくこともある
  2. Cache-Controlヘッダーを使用する方法
    - 現在時刻からの秒数で新鮮である時間を指定する
    - 定期更新でないもの、サーバの負荷からアクセス頻度を下げたい場合、リアルタイム性がそれほど重要でない情報、に使われる
#### 4-3-2. 検証モデル(Real World HTTPのP58からが詳しく載っている)
- 今持っているキャッシュのデータが有効かどうかをサーバに問い合わせるモデル
- 「Last-ModifiedヘッダーとIf-Modified-Sinceヘッダー」または「EtagヘッダーとIf-None-Match」を使用する
  - ETagヘッダー : レスポンスデータのハッシュを表す。レスポンスデータに変化があったらハッシュも変化する
  - If-None-Matchヘッダー : クライアントからの条件付きリクエスト。ここに記されている日時とサーバのデータの日時が等しいかどうか
  - Last-Modifiedヘッダー : クライアントからの条件付きリクエスト。ここに記されているハッシュ値とサーバのデータのハッシュ値が等しいかどうか
- サーバ側は、変更があれば304、変更がなければ200というステータスコードとともに変更されたデータを返して、またクライアントがそのデータをキャッシュする
- HTTPには強い検証と弱い検証という二つの方法も存在しているのでよく調べる

#### 次はP117からやる
