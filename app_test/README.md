# 初めての自動テスト　書籍メモ

## わかったこと
- レイヤードアーキテクチャがテスタブルなコードである理由
  - 依存先が一つだから、一つの依存先をモックするだけでユニットテストが行える
    - もし依存先が複数ある場合はモックをその数だけ用意することになるから大変
  - 依存元は依存先のinterfaceを渡せば動作するということが重要
    - interfaceでなく、実際の実装だった場合は本番の構造体とtest構造体を切り替えれない
    - interfaceであることで、interfaceを満たしているものは何が実装されていようとも受け取れる

- 「外界をinterfaceで定義する」という考え方
  - 外部APIを使いたい場合やDBを使いたい場合に、依存する窓口をinterfaceにするという考え方
  - この考え方はテストがしやすくするためのもの。これをレイヤーとして捉えて積み重ねたものがレイヤードアーキテクチャ

- CI/CDツールが行うこと
  - APIテストは統合テストのこと
  - 単体テストがユニットテストのこと
  - 用意したテストを自動で実行して、デプロイまで行ってくれるツールのこと
  - CircleCIとかJenkinsとか
  - https://qiita.com/gold-kou/items/4c7e62434af455e977c2

  ![automation-test](https://user-images.githubusercontent.com/53253817/100777311-fd7c3f00-3448-11eb-8c31-b52098e2442b.png)

- DBを含めたユニットテストを実現する方法
  1. dockerでDBを用意する
  2. mockを使う

## 有用な記事
- golangでinterfaceを使ったテスト(mock)
  - https://deeeet.com/writing/2016/10/25/go-interface-testing/
  - http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/
- golangでテスト入門
  - https://future-architect.github.io/articles/20200601/
- pythonのmockは簡単すぎてすごい、、
  - モックにしたいところにMagicMockを代入するだけという、、
  - https://note.crohaco.net/2015/python-mock/

<br></br>

## 1.テストのピラミッド

### 1-1.先人の教訓
1. 全ての自動テストが同等の力を持つわけではない
2. テストを「書くことができる」状態が、「書くべき」だという理由にはならない
3. スピードとフィードバックが重要
- つまり、1つのテストが万能薬のように働くことはない！
  - うまく組み合わせて用いることが必要

### 1-2.テストのピラミッド
- UIテスト
  - メリット
    - エンドツーエンドで動く
    - ユーザと同じ対象を見る
  - デメリット
    - 高コストで遅い
  
- 統合テスト
  - メリット
    - WebサービスとAPIがテストできる
    - つながりを見られる
  - デメリット
    - 詳細さに欠ける

- ユニットテスト
  - メリット
    - 超高速
    - 多目的に利用できる
  - デメリット
    - 結合部分の確認に弱い

![https---qiita-image-store s3 ap-northeast-1 amazonaws com-0-390780-0e68ad80-e3a8-cc79-6be2-3bbe69d24389](https://user-images.githubusercontent.com/53253817/100713784-2b856300-33f8-11eb-83e6-c496e336937c.png)

### 1-3.自動テストの方針
- UIテストよりユニットテストを優先する
- ユニットテストで埋められない部分を統合テストでカバーする
- UIテストは限定的に使う
- まず「ユニットテストでカバーできないか？」を考える
  - ユニットテストでカバーできないなら、統合テストでカバーできるか考えるといったように段階的にどの層テストを適用するか考える
- 全てを自動化しようとせず、代わりに、過不足なく自動化すること
- 上位と下位のテストがかぶることもある
  - ただしそれらはスコープが違う
  - 協調して無意味な重複を避けていくことが大事
- 探索的テスト(手順化されてないテスト)も忘れないこと

### 1章の疑問
- レイヤードアーキテクチャで考えたときにpresentation、usecase、infraのそれぞれをユニットテストすることはないのか？
  - ある。UIテストというのはUIのテストというよりはUIを通してE2Eでテストをすること。UIをユニットテストするには後述するJavaScriptの方法で行える
  - usecaseに関しても後述するモック化などを使ってユニットテストを行う

- 探索的テストってなんだろう？

<br></br>

## 2.UIテストに触れる

### 2-2.UIテストを始める
- UIテストの手順
  1. 自分がユーザになりきって、どのような手順を踏むか自然言語で書き出す
    - ログイン画面を開く
    - メールアドレスを入力する
    - パスワードを入力する
    - サインインボタンをクリックする
    - welcomeというメッセージが表示されていることを確認する
  2. 自然言語をコードに変換する
    - １の手順を一行一行コードに変換するだけ

    ```ruby
    describe 'should be able to login' do  #テスト名
      let(:user) { FactoryGirl.create(:user) }  #ダミーテスト作成
      before do
        visit login_path  #URLを叩いてログイン画面を開く
        fill_in 'Email', with: user.email  #ダミーテストを参照してテキストボックスを埋める
        fill_in 'Pasword', with: user.password  #同じくダミーテストを参照してテキストボックスを埋める
        click_button 'Sign in'  #サインインボタンをクリックする
      end
      it { should have_selector('h1', text: 'Welcome') }  #ログイン後の画面にh1タグのWelcomeが表示されているかを確認する
    end
    ```

### 2-3~6.UIテストでの遷移先の検証
- UIテストで遷移先の画面が正しいかを判定する方法
  - HTMLタグをCSSセレクタを使って取得することで、遷移先の画面が正しいかを判別する
  - HTMLタグのclassを指定してしまうと、被る可能性があるので、IDを指定する
  - HTMLを開発するときにテストで取得するタグには「できるだけ」IDタグを付与するようにする
  - IDタグを付与する場所は「テストで取得する箇所」と「JavaScriptを適用する箇所」

<br></br>

## 3.レガシーシステムにUIテストを追加する

### 3-1~2.UIテストを適用するステップ
1. URLが意図している画面に遷移するかを確認する
  - URLを叩いた先のHTMLをprintとかで取得して、テストした画面に行けるかを目視する
2. 正しいCSSセレクタを見つける(3の方法が良さそうかな)...あるページのテストに使うセレクタは全て取得しておく
  1. ソースを表示してHTMLから自力でタグを探して、IDかclassが付与されていなかったら付与する
  2. デベロッパーツールを使って、CSSセレクタを取得して、IDかclassが付与されていなかったら付与する
  3. デベロッパーツールのコンソールにCSSセレクタを打ち込んで欲しい箇所が取得できるか確認して、確認できたらそのCSSセレクタを使用する
3. ダミーデータを作成する
4. アサーションを追加する(サインアップを例にする)
  - 有効な認証情報を入力したユーザがサインアップできる
  - 無効な認証情報を入力したユーザがサインアップできない

### UIテストを適用する時のポイント
- テストは緩く書くこと
  - 例えば、「success」という文字列の照合をするのではなくて、successが表示されるところに文字列が存在するかどうかで判定するとか

<br></br>

## 4.統合テストで点と点を結ぶ

### 4-2~4-4.Webの仕組み
- URLを叩いてからレスポンスが返ってくるまでの仕組み

  ![How-The-Web-Works jfif](https://user-images.githubusercontent.com/53253817/100647584-1a4e3f00-3383-11eb-9d81-aad2fb6c7d60.jpeg)

- UIが無くてもWebの仕組みに則って統合テストを行える
  - 全てはHTTPリクエストに変換されるから
  - フォームに入力された情報もボタンを押した情報も全てHTTPリクエストに変換して送信されている
  - UIがない場合というのは、WebAPIのようなものをテストするときのこと

- HTTPリクエストとレスポンスを覗く
  - デベロッパーツールのnetworkタブでリクエストとレスポンスの流れと、中身を見ることができる
  - これを統合テストを書くときの材料にできるので覚えておく

- 統合テストはURLを軸にしてテストを駆動させる

<br></br>

## 5. RESTfulなWebサービスの統合テスト

### 5-2.HTTP GETのテスト
- GETを最も簡単にテストする方法
  - ブラウザにURLを入力してエンター

- GETをコードでテストする
  - GETした結果のデータとステータスコードをテストする(200okとか302リダイレクトとか)

  ```ruby
  def setup
    @permit = permits(:saskatoon) #テストデータを作成
  end

  test 'HTTP GET' do
    get permit_path(:id => @permit.id, :format => :json)  #GETを生成してURLに送信する
    assert response.body.to_s.include? 'Saskatoon'  #レスポンスにSaskatoonという文字は含まれているか確認
    assert_response :success #200 ok ステータスコードの確認
  ```

### 5-3.HTTP POSTのテスト
- 自然言語で記述してみる
  - 適当な属性を作って既存の許可情報を検索する
  - 対象が存在しないことを確認する
  - 新しい許可情報を作成する
  - 再度検索を行う
  - 対象の許可情報が作成されていることを確認する

- コードに変換する

  ```ruby
  test 'HTTP POST' do
    # 既存の許可情報を検索する
    permit = Permit.find_by_location('Moose Jaw')

    # 対象が存在しないことを確認する
    assert_nil permit

    # 新しい許可情報を作成する
    post permits_path, permit: (location: 'Moose Jaw')

    # 再度検索を行う
    permit = Permit.find_by_location('Moose Jaw')

    # 対象の許可情報が作成されていることを確認する
    assert_not_nil permit

    # ステータスコードが302であることを確認する
    assert_response :redirect
  ```

### 5-4.HTTP PUTのテスト
- POSTに似た動作

```ruby
test 'HTTP PUT' do
  # 既存の許可情報を検索する
  permit = Permit.find_by_location('Moose Jaw')

  # 対象が存在しないことを確認する
  assert_nil permit

  # 情報を更新する
  put permit_path(@permit), permit: {location: 'Medicine Hat'}

  # 再度検索を行う
  permit = Permit.find_by_location('Medicine Hat')

  # 対象の許可情報が存在することを確認する
  assert_not_nil permit

  # レスポンスのステータスコードを確認する
  assert_response :redirect
end
```

### 5-5.HTTP DELETEのテスト
- 削除したい許可情報のIDと一緒にDELETEのリクエストを送るだけ

```ruby
test 'HTTP DELETE' do
  delete permit_path(@permit)
  assert_response :redirect

  assert_raises(ActiveRecord::RecordNotFound) do
    get permit_path(@permit)
  end
end
```

### 5-6.まとめ
- RESTfulなサービスをテストするには、正しいURLを生成して、適切なHTTPメソッドとデータを送信する
- HTTPのステータスコードをテストに活用する
- ブラウザのデベロッパーツールのnetworkタブなどでHTTPメソッドの種類や中身のデータを確認してテストに活用する

<br></br>

## 6.ユニットテストで基礎を固める

- ユニットテストで確認するエラー
  - エッジケース
    - 境界値ギリギリの値を入力したらどのようになるかのテスト
  - off-by-oneエラー
    - 繰り返し構文で、1回多いとか1回少ないとかのテスト
  - ロジックのエラー
    - アプリケーション固有のエラーに対するテスト
  - etc

### 6-4.ユニットテストの仕組み
- クラス、メソッド、前提条件といった物に対してテストを書くこと

- 新しい機能を追加するたびにユニットテストを書くが重要

- ユニットテストを書くときに考慮するポイント
  1. ハッピーパス
    - 全てが正しく動いたと仮定して、理想的な条件下でメソッドはどう動作するか？
    - 全てがうまく動く場合のテストシナリオのこと
  2. 特殊ケース
    - 特に注意を払うべき特殊な条件やエッジケースはあるか？
  3. 例外
    - どんな条件や例外が起きた時にこのメソッドはエラーを起こしうるか？
  4. プログラムのロジックと流れ
    - プログラムの全てのパス、ロジックの流れ、条件分岐は適切に動いているか？
  5. その他何でも(問題を起こしそうな箇所)
    - このメソッドが正しく動いていることに自信を持つには、他にどんなテストが必要か？

- TDDとは
  - ユニットテストを先に書いてから、それを満たすように実装をしていくこと
  - テストファーストともいう

- コードカバレッジとは？
  - コードに対してテストコードがどれだけカバーできているかの指標
  - ツールが計算してくれる
  - この数値を追いすぎるのはよくないが、一つの指標として

### 6-5.上級テクニック
- ユニットテストではネットワークに接続してデータを受け取ることを避けて、テストデータを自前で作成して、データを受け取ったという設定でテストを進める
  - 例えばDBからデータを取得するメソッドのテストを書きたかったら、テストデータを用意してメソッドに渡してテストをする

- DIとモック
  - レイヤードアーキテクチャのように依存関係が定義されているものをテストする方法
  - テストするのに依存先のクラスのオブジェクトが必要な場合に使うのがDIとモック
  - モックとはクラスのダミーオブジェクト
    - goにモックを作成するライブラリがあるからそれを使うと作成できる
  - DIはそのダミーオブジェクトを注入すること

### 6-6.まとめ
- ユニットテストは他の階層に比べて多くのテストをになっていて、基板のような存在
- ユニットテストは高速に実行できるため、迅速なフィードバックを得られる
- ユニットテストは極めて局所的に書くことが多く、ネットワークに接続するような処理は避けたほうがいい
- モック化は、テストしたいコードに置いてアクセス困難な箇所もテストできるようにするための技術である

<br></br>

## JavaScriptを使ったブラウザ上のユニットテスト

- Ajaxとは
  - webページ全体を再読み込みすることなく、ブラウザ上で動作しているJavaScriptのプログラムがバックエンドのサーバとデータを送受信することができる仕組み

- DOMとは
  - JavaScriptとHTMLの間を繋ぐ概念
  - JavaScriptはDOMを使ってHTMLを操作している

### 7-4.UIのバグ探しの手順
1. HTMLを調べる
  - JavaScriptのデバッグを行うときは、状況を把握するためにJavaScriptが動いているHTMLの構造を調べる
  - どのようなclassやIDが振られているのか、UIのどの部分がどのHTMLにあたるのかといったことを見る

2. JavaScriptを解析する
  - バグに該当する処理をしているJavaScriptのコードを見る
  - ここではどの関数がどのような処理をしているのかといった理解をする

3. テストを書く
  - バックエンドのテストと同じように、テストデータを作る。この場合はHTML自体をテストデータとして作成する

<br></br>

## 8-1.ピラミッドの具体例

### 8-2.ユニットテストから始める
- P134の図

### 8-3.統合テストへステップアップする
- P135の図

### 8-4.UIテストへ到達する
- P136の図

### 8-7.まとめ
- テストの大部分をピラミッドのユニットテストのレベルで行う
- 統合テストのレベルでは、なるべく多くの接続テストを行い、ユニットテストで捉えきれない溝を埋める
- UIテストは限定的に行う。UIテストで詳細を見ることにコストをかけるべきではない

<br></br>

## 9.プログラミング初級講座

### 9-2.コーディングスタイル
- 適切な命名
  - 英単語の区切り方にキャメルケースといった名前がついている

- スペースの入れ方
  - インデントを意識して読みやすいように
  - ホワイトスペースを活用しながら、コメントを活用する
    - ホワイトスペースは、例えばメソッド内のコードをスペース無しで書くのではなくて、見やすいようにスペースを挿入して書くこと

- コードの重複
  - rubyだとsetupメソッドなどで最初に共通部分を定義出来たりする
  - なんでも共通化すればいいというわけではないので注意

<br></br>

## 10.テストを整理する

### 10-3.コンテキストを明確化
- P179の図

- テストのまとまりごとにクラス分割をする

- ディレクトリ分割は、テストのまとまりごとに行って分割する

<br></br>

## 11.効果的なモックの活用

### 11-3.

- モックとスタブの違い
  - スタブは単にハードコードしたテストデータ
  - モックは特定のオブジェクトの代理をしてユニットテストを円滑に進めるためのもの
    - 例えば、PostgreSQLを用いたテストをやりたくてもすぐに準備できない時に、PostgreSQLをモックすることでテストを行える
    - または、外部依存がないテストを行いたい時にも使える
