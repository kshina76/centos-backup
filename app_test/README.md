# 初めての自動テスト　書籍メモ

## 1.テストのピラミッド

### 1-1.先人の教訓
1. 全ての自動テストが同等の力を持つわけではない
2. テストを「書くことができる」状態が、「書くべき」だという理由にはならない
3. スピードとフィードバックが重要
- つまり、1つのテストが万能薬のように働くことはない！
  - うまく組み合わせて用いることが必要

### 1-2.テストのピラミッド
- UIテスト（Presentation層〜infra層）
  - メリット
    - エンドツーエンドで動く
    - ユーザと同じ対象を見る
  - デメリット
    - 高コストで遅い
  
- 統合テスト（usecase層〜infra層）
  - メリット
    - WebサービスとAPIがテストできる
    - つながりを見られる
  - デメリット
    - 詳細さに欠ける

- ユニットテスト（infra層）
  - メリット
    - 超高速
    - 多目的に利用できる
  - デメリット
    - 結合部分の確認に弱い

![https---qiita-image-store s3 ap-northeast-1 amazonaws com-0-390780-0e68ad80-e3a8-cc79-6be2-3bbe69d24389](https://user-images.githubusercontent.com/53253817/100713784-2b856300-33f8-11eb-83e6-c496e336937c.png)

### 1-3.自動テストの方針
- UIテストよりユニットテストを優先する
- ユニットテストで埋められない部分を統合テストでカバーする
- UIテストは限定的に使う
- まず「ユニットテストでカバーできないか？」を考える
  - ユニットテストでカバーできないなら、統合テストでカバーできるか考えるといったように段階的にどの層テストを適用するか考える
- 全てを自動化しようとせず、代わりに、過不足なく自動化すること
- 上位と下位のテストがかぶることもある
  - ただしそれらはスコープが違う
  - 協調して無意味な重複を避けていくことが大事
- 探索的テスト(手順化されてないテスト)も忘れないこと

### 1章の疑問
- レイヤードアーキテクチャで考えたときにpresentation、usecase、infraのそれぞれをユニットテストすることはないのか？
  - 上の説明だとusecase層をテストすることは統合テストを行うのであって、ユニットテストをすることでは内容に見えるが

- 探索的テストってなんだろう？

<br></br>

## 2.UIテストに触れる

### 2-2.UIテストを始める
- UIテストの手順
  1. 自分がユーザになりきって、どのような手順を踏むか自然言語で書き出す
    - ログイン画面を開く
    - メールアドレスを入力する
    - パスワードを入力する
    - サインインボタンをクリックする
    - welcomeというメッセージが表示されていることを確認する
  2. 自然言語をコードに変換する
    - １の手順を一行一行コードに変換するだけ

    ```ruby
    describe 'should be able to login' do  #テスト名
      let(:user) { FactoryGirl.create(:user) }  #ダミーテスト作成
      before do
        visit login_path  #URLを叩いてログイン画面を開く
        fill_in 'Email', with: user.email  #ダミーテストを参照してテキストボックスを埋める
        fill_in 'Pasword', with: user.password  #同じくダミーテストを参照してテキストボックスを埋める
        click_button 'Sign in'  #サインインボタンをクリックする
      end
      it { should have_selector('h1', text: 'Welcome') }  #ログイン後の画面にh1タグのWelcomeが表示されているかを確認する
    end
    ```

### 2-3~6.UIテストでの遷移先の検証
- UIテストで遷移先の画面が正しいかを判定する方法
  - HTMLタグをCSSセレクタを使って取得することで、遷移先の画面が正しいかを判別する
  - HTMLタグのclassを指定してしまうと、被る可能性があるので、IDを指定する
  - HTMLを開発するときにテストで取得するタグには「できるだけ」IDタグを付与するようにする
  - IDタグを付与する場所は「テストで取得する箇所」と「JavaScriptを適用する箇所」

<br></br>

## 3.レガシーシステムにUIテストを追加する

### 3-1~2.UIテストを適用するステップ
1. URLが意図している画面に遷移するかを確認する
  - URLを叩いた先のHTMLをprintとかで取得して、テストした画面に行けるかを目視する
2. 正しいCSSセレクタを見つける(3の方法が良さそうかな)...あるページのテストに使うセレクタは全て取得しておく
  1. ソースを表示してHTMLから自力でタグを探して、IDかclassが付与されていなかったら付与する
  2. デベロッパーツールを使って、CSSセレクタを取得して、IDかclassが付与されていなかったら付与する
  3. デベロッパーツールのコンソールにCSSセレクタを打ち込んで欲しい箇所が取得できるか確認して、確認できたらそのCSSセレクタを使用する
3. ダミーデータを作成する
4. アサーションを追加する(サインアップを例にする)
  - 有効な認証情報を入力したユーザがサインアップできる
  - 無効な認証情報を入力したユーザがサインアップできない

### UIテストを適用する時のポイント
- テストは緩く書くこと
  - 例えば、「success」という文字列の照合をするのではなくて、successが表示されるところに文字列が存在するかどうかで判定するとか

<br></br>

## 4.統合テストで点と点を結ぶ

### 4-2~4-4.Webの仕組み
- URLを叩いてからレスポンスが返ってくるまでの仕組み

  ![How-The-Web-Works jfif](https://user-images.githubusercontent.com/53253817/100647584-1a4e3f00-3383-11eb-9d81-aad2fb6c7d60.jpeg)

- UIが無くてもWebの仕組みに則って統合テストを行える
  - 全てはHTTPリクエストに変換されるから
  - フォームに入力された情報もボタンを押した情報も全てHTTPリクエストに変換して送信されている
  - UIがない場合というのは、WebAPIのようなものをテストするときのこと

- HTTPリクエストとレスポンスを覗く
  - デベロッパーツールのnetworkタブでリクエストとレスポンスの流れと、中身を見ることができる
  - これを統合テストを書くときの材料にできるので覚えておく

- 統合テストはURLを軸にしてテストを駆動させる

<br></br>

## 5. RESTfulなWebサービスの統合テスト

### 5-2.HTTP GETのテスト
- GETを最も簡単にテストする方法
  - ブラウザにURLを入力してエンター

- GETをコードでテストする
  - GETした結果のデータとステータスコードをテストする(200okとか302リダイレクトとか)

  ```ruby
  def setup
    @permit = permits(:saskatoon) #テストデータを作成
  end

  test 'HTTP GET' do
    get permit_path(:id => @permit.id, :format => :json)  #GETを生成してURLに送信する
    assert response.body.to_s.include? 'Saskatoon'  #レスポンスにSaskatoonという文字は含まれているか確認
    assert_response :success #200 ok ステータスコードの確認
  ```

### 5-3.HTTP POSTのテスト
- 自然言語で記述してみる
  - 適当な属性を作って既存の許可情報を検索する
  - 対象が存在しないことを確認する
  - 新しい許可情報を作成する
  - 再度検索を行う
  - 対象の許可情報が作成されていることを確認する

- コードに変換する

  ```ruby
  test 'HTTP POST' do
    # 既存の許可情報を検索する
    permit = Permit.find_by_location('Moose Jaw')

    # 対象が存在しないことを確認する
    assert_nil permit

    # 新しい許可情報を作成する
    post permits_path, permit: (location: 'Moose Jaw')

    # 再度検索を行う
    permit = Permit.find_by_location('Moose Jaw')

    # 対象の許可情報が作成されていることを確認する
    assert_not_nil permit

    # ステータスコードが302であることを確認する
    assert_response :redirect
  ```

### 5-4.HTTP PUTのテスト
- POSTに似た動作

```ruby
test 'HTTP PUT' do
  # 既存の許可情報を検索する
  permit = Permit.find_by_location('Moose Jaw')

  # 対象が存在しないことを確認する
  assert_nil permit

  # 情報を更新する
  put permit_path(@permit), permit: {location: 'Medicine Hat'}

  # 再度検索を行う
  permit = Permit.find_by_location('Medicine Hat')

  # 対象の許可情報が存在することを確認する
  assert_not_nil permit

  # レスポンスのステータスコードを確認する
  assert_response :redirect
end
```

### 5-5.HTTP DELETEのテスト
- 削除したい許可情報のIDと一緒にDELETEのリクエストを送るだけ

```ruby
test 'HTTP DELETE' do
  delete permit_path(@permit)
  assert_response :redirect

  assert_raises(ActiveRecord::RecordNotFound) do
    get permit_path(@permit)
  end
end
```

### 5-6.まとめ
- RESTfulなサービスをテストするには、正しいURLを生成して、適切なHTTPメソッドとデータを送信する
- HTTPのステータスコードをテストに活用する
- ブラウザのデベロッパーツールのnetworkタブなどでHTTPメソッドの種類や中身のデータを確認してテストに活用する

<br></br>

## 6.ユニットテストで基礎を固める

- ユニットテストで確認するエラー
  - エッジケース
    - 境界値ギリギリの値を入力したらどのようになるかのテスト
  - off-by-oneエラー
    - 繰り返し構文で、1回多いとか1回少ないとかのテスト
  - ロジックのエラー
    - アプリケーション固有のエラーに対するテスト
  - etc

### 6-4.ユニットテストの仕組み
- クラス、メソッド、前提条件といった物に対してテストを書くこと

- 新しい機能を追加するたびにユニットテストを書くが重要

- ユニットテストを書くときに考慮するポイント
  1. ハッピーパス
    - 全てが正しく動いたと仮定して、理想的な条件下でメソッドはどう動作するか？
    - 全てがうまく動く場合のテストシナリオのこと
  2. 特殊ケース
    - 特に注意を払うべき特殊な条件やエッジケースはあるか？
  3. 例外
    - どんな条件や例外が起きた時にこのメソッドはエラーを起こしうるか？
  4. プログラムのロジックと流れ
    - プログラムの全てのパス、ロジックの流れ、条件分岐は適切に動いているか？
  5. その他何でも(問題を起こしそうな箇所)
    - このメソッドが正しく動いていることに自信を持つには、他にどんなテストが必要か？

- TDDとは
  - ユニットテストを先に書いてから、それを満たすように実装をしていくこと
  - テストファーストともいう

- コードカバレッジとは？
  - コードに対してテストコードがどれだけカバーできているかの指標
  - ツールが計算してくれる
  - この数値を追いすぎるのはよくないが、一つの指標として

### 6-5.上級テクニック
- ユニットテストではネットワークに接続してデータを受け取ることを避けて、テストデータを自前で作成して、データを受け取ったという設定でテストを進める
  - 例えばDBからデータを取得するメソッドのテストを書きたかったら、テストデータを用意してメソッドに渡してテストをする

- DIとモック
  - レイヤードアーキテクチャのように依存関係が定義されているものをテストする方法
  - テストするのに依存先のクラスのオブジェクトが必要な場合に使うのがDIとモック
  - モックとはクラスのダミーオブジェクト
    - goにモックを作成するライブラリがあるからそれを使うと作成できる
  - DIはそのダミーオブジェクトを注入すること

### 6-6.まとめ
- ユニットテストは他の階層に比べて多くのテストをになっていて、基板のような存在
- ユニットテストは高速に実行できるため、迅速なフィードバックを得られる
- ユニットテストは極めて局所的に書くことが多く、ネットワークに接続するような処理は避けたほうがいい
- モック化は、テストしたいコードに置いてアクセス困難な箇所もテストできるようにするための技術である
