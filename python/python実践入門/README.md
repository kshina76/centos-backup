# Python実践入門 書籍メモ

## 第2章 pythonの実行
### docstring
- クラスやメソッドや関数にドキュメントを埋め込むことができる
- pythonの対話モードでhelp関数の中に組み込み関数などを入れて実行すると、サッと仕様を見ることができる
  - その際に表示されているのがdocstring
- docstringとコメントの使い分け
  - 必要な情報をdocstringに書いて、補足内容はコメントで

<br></br>

## 第3章 基本となる文法
### 変数
- Pythonでは定数を宣言することができない
  - ミュータブルだが、定数としてプログラマに伝えたい場合は、定数名をすべて大文字（＋アンダースコア）で構成するのが慣例
- コンテナオブジェクト
  - 別のオブジェクトを要素として持つもの
  - 文字列、辞書、集合、タプル、リストなど
- 返り値やfor文の変数を利用しない場合
  - `_`で受けて、利用しないということを明示する
### 条件分岐
- 偽となる値
  - None
  - False
  - 数値型のゼロ。0、0.0、0j
  - 文字列、辞書、集合、タプル、リストなどの空オブジェクト
  - メソッド`__bool__()`がFalseを返すオブジェクト
  - メソッド`__bool__()`が定義されていなくて、メソッド`__len__()`が0を返すオブジェクト
- 真となる値
  - 上記の偽となる値以外
- 数値の比較
  - 知っているので略
- オブジェクト同士の比較
  - `==`、`!=`、`is`、`is not`
  - `is`と`is not`はオブジェクトが同一かどうかを判定する(同じポインタを参照しているかどうか)
  - `None`は`is`や`is not`で判定する
- コンテナオブジェクトで使用できる演算子
  - `in`、`not in`
- pythonicな書き方
  - 空のオブジェクトが偽を表すことを利用して`if num_list == None:`ではなくて、`if num_list:`と書く
### ループ処理
- pythonのfor文は変数のスコープをブロック内に限定しない
  - 変数`i`とかが外に出ても有効ということ
### セイウチ演算子
- python3.8で追加された`:=`という演算子
- 可読性が悪くなる可能性が高いので、可読性がよくなると思った時だけ使用する
- 本家本元の呼び出し元に例外が送出される。`try-except`されるまで登っていく
### 例外処理
- Pythonで例外が発生するとプログラムが強制終了する
- 強制終了させたくない場合は`try-except`で例外をキャッチする
- except: 例外が発生した時に走る処理
- else: 例外が発生しなかった場合に走る処理
- finally: 例外の有無に限らず走る処理
  - ファイルやdbのクローズなどの「クリーンナップ処理」をするときに使用する
- 例外を意図的に発生させるには`raise`を使用する
- 独自の例外を定義するには`Exceptionクラス`を継承して作成する
### with構文
- ファイルをオープンする処理などの時に、closeを明示的に書かなくても勝手に閉じてくれる

<br></br>

## 第4章 データ構造
- pythonでは全ての型は`Object`を継承しているので、「型=クラス」として読み替えて大丈夫
### NaN
- NaNはfloat型
- `float("nan")`でNaNを呼び出せる
### 0.1+0.1+0.1=0.3問題
- 計算機は`0.3`や`0.8`を正確に表せない
- `round`関数を使ったりして対処する
- https://style.nikkei.com/article/DGXMZO49515450W9A900C1000000/
### 文字列
- str型をfor文で回すと

  ```python
  for i in "python":
      print(i)

  '''
  実行結果
  p
  y
  t
  h
  o
  n
  '''
  ```

- 文字列内での変数の利用
  - `f-string`または`format()`または`%演算子`
  - `f-string`を使用する

- str型とよく似たbytes型
  - これらの型は相互に変換可能
### Unicode
- あとで調べる
### 配列(list)
- 追加と削除
  - appendで追加
  - popまたはdelで削除
- 要素とインデックスの値の関係
  - P82の画像
### タプル(tuple)
- 要素が一つの時は`(1,)`のようにカンマを加える
  - `(3+2)/2`などのようなものと区別するための仕様
- 空のタプルは`()`で定義されている。カンマはいらないことに注意
- リストとタプルの使い分け
  - 可変(ミュータブル)はリスト、不変(イミュータブル)はタプル
### 辞書(dict)
- 要素へのアクセス
  - `インデックス`または`get`
  - なかった時に例外を発生させたくない場合は`get`を使用
- キーに使えるオブジェクトの制限: イミュータブルなものだけ
  - 数値、文字列、タプルなど
### 集合(set)
- `{要素1, 要素2, ...}`のように定義
- frozenset型は不変な集合を定義
- 重複要素は一つになる
- 集合演算
  - `setA | setB`: 和集合
  - `serA - setB`: 差集合
  - `setA & setB`: 積集合
  - `setA ^ setB`: 対称差
  - `issubset()`: 部分集合判定
### 内包記法
- if文付き
  - `[i for i in range(10) if i == 2]`
- list型
  - `[i for i in range(10)]`
- set型
  - `{i for i in range(10)}`
- 辞書型
  - `{str(i): i for i in range(10)}`
- ジェネレータ
  - `(i for i in range(10))`
### pythonのオブジェクトの種類
- 可変(ミュータブル)オブジェクト
  - list、set、dictなど
- 不変(イミュータブル)オブジェクト
  - str、タプル、frozensetなど
- コンテナオブジェクト
  - 他のオブジェクトの参照を持つもの
  - リスト、タプル、辞書、集合など
- イテラブルなオブジェクト
  - `__iter__()`を実装したオブジェクト
- コーラブルなオブジェクト
  - 関数やクラスオブジェクトのように`()`を付けて呼び出せるもの

<br></br>

## 関数
- pythonでは関数もオブジェクトなので、変数に関数を代入できる
- returnが無い場合の戻り値は`None`になる
### 位置引数
- `func(1, 2)`のように引数名を指定しない渡し方
### キーワード引数
- `func(a=1, b=2)`のように引数名を指定して呼び出す方法
- キーワード引数を使う場合は引数の順番はなんでも良い
  - `func(b=2, a=1)`でも同じ結果になる
### デフォルト値の落とし穴
- デフォルト引数は関数の定義時に評価される
- デフォルト値に可変(ミュータブル)なオブジェクトを指定してはいけない。代わりに`None`を指定する

```python
# 関数定義時の時刻が常にデフォルト引数になってしまう
def print_page(content, timestamp=datetime.now()):
    print(content)
    print(timestamp)

# 正しくは以下のように実装する
def print_page(content, timestamp=None):
    if timestamp is None:
        timestamp = datetime.now()
    print(content)
    print(timestamp)
```

### 可変長の位置引数
- `*args`を宣言
### 可変長のキーワード引数
- `**kargs`を宣言
### 引数リストのアンパック
- リストや辞書に格納された値を引数に展開する

```python
hikisu = ["1", "2"]
func(*hikisu)
```

### lambda式
- `lambda 引数1, 引数2,...: 戻り値になる式`
### 型ヒント（アノテーション）
- `Optional`は`None`の可能性がある場合に使用する
- `mypyライブラリ`を使用すると型にミスがあるとエラーを吐いてくれる

```python
def func(arg1: arg1の型, arg2: arg2の型) -> 返り値の型:
    処理
    return
```

```python
from typing import Optional
def sum_a_b(a: int = 0, b: int) -> Optional[int]
    if a > 0 and b > 0:
      return a + b
    return None
```

<br></br>

## 第6章 クラスとインスタンス
- ここは結構重いからあとで見直す
### プロパティ、property
- `@property`を使用すると、インスタンスメソッドをインスタンス変数のように扱えるようになる
- インスタンスメソッドを`()`を付けないで呼び出せるようになる

<br></br>

## 第7章 モジュールとパッケージ、名前空間とスコープ
### モジュールとパッケージ
- 複数の関数やクラスをまとめたpyファイルをモジュールという
- 複数のpyファイルをまとめたものをパッケージというが、プログラム的にはモジュールとパッケージに差異はないため、まとめてモジュールとして説明している場合もある
### __init__.pyの使い方
1. 複数のモジュールをまとめたパッケージであることの目印
  - pythonには複数のモジュールをまとめる機能があって、パッケージという
  - パッケージとして扱うディレクトリに`__init__.py`ファイルを置いておくと、パッケージとして扱うという目印になる
  - `__init__.py`を作らなくてもパッケージとして扱われるが、とりあえず置いておくといいと思う

2. パッケージの初期化
  - パッケージがimportされると、`__init__.py`の内容が最初に実行される

3. パッケージをライブラリとして公開する時
  - `<パッケージ名>.<属性名>`で呼び出せるようにする
  - 原理
    - b64ディレクトリに定義された`__init__.py`ファイルが`import b64`された時に呼び出される
    - `__init__.py`のトップレベルにある属性(str_to_base)は`<パッケージ名>.<属性名>`で呼び出せるようになる

  ```python
  # __init__.py
  from .decode import str_to_base64

  # b64/encode.py
  def str_to_base64():
      pass
  
  # main.py
  import b64
  b64.str_to_base64()
  
  # または
  from b64 import str_to_base64
  str_to_base64()
  ```

  - もしこの便利機能を使わない場合
    - pyファイル名まで指定しないとimportできなくなる

    ```python
    from b64 import decode
    decode.str_to_base64()
    ```

### importの検索パス
- 以下のコードでimportする際にpythonが探すパスを表示して見ることができる

  ```python
  import sys
  print(sys.path)
  ```

### PYTHONPATH
- 検索パスにパスを追加することができる

### 名前空間とスコープ
- pythonには4つのスコープがある
  - ローカルスコープ
    - 関数(メソッド)内のスコープ
  - エンクロージングスコープ
    - クロージャのスコープ
  - グローバルスコープ
    - ファイル直下のスコープ
  - ビルトインスコープ
    - TrueやFalseなどの最初から組み込まれているスコープ

<br></br>

## 第8章 組み込み関数と特殊メソッド
- 組み込み関数と特殊メソッドの紹介なので、暇な時に見る
### isinstance,issubclass,callable
### hasattr
### getattr,setattr,delattr

<br></br>

## 第9章 Python特有の様々な機能
- P201から読み始める
