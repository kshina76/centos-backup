# 自走プログラマー 書籍メモ
## 自分メモ
- `@dataclass`の使い方
  - https://myenigma.hatenablog.com/entry/2020/03/07/171015
- `@property`の使い方
  - getterやsetterのような直接書き出しを禁止したい場合などに使う
  - http://nametake-1009.hatenablog.com/entry/2015/10/21/222829
- pytestのparametrize

## 関数設計
### 関数名は内容を想像できる名前にする
- 動詞にする例
  - `get_item_list`、`calc_tax`、`is_member`
- 取得できるものの名詞にする例
  - `current_date`、`as_dict`
- 役割で関数名にする例
  - `json_parser`
### 関数名ではより具体的な意味の英単語を使おう
- `get`だけだと「取る」という意味しか得られない
- 計算する場合は`calc`などに置き換えたほうがいい
- 要は狭い意味の単語を使うように心がけたほうがいいということ
  - `get`だと広すぎる
- P14,15の画像
### 関数名から想像できる型の返り値を返す
- `is_`や`has_`はbool型を返す
- `is_`や`has_`は値を書き換えたり外部にアクセスするようなことが無いように、副作用の無い関数に使うようにする
- 関数の定義やドキュメントを読まなくても挙動がわかるようになる
### 意味づけできるまとまりで関数をまとめる
- `print_`とかはやめよう
### リストや辞書や集合をデフォルト引数にしない
- `def func(li = [])`はダメ
- ミュータブル(可変)な値はデフォルト引数にしてはいけない
- デフォルト引数は関数呼び出しの度に初期化されないから、呼び出される度に内容が変わってしまう

- 良い例
  - `None`だった場合に`[]`などで初期化するという処理を書く

  ```python
  def func(li = None):
      if li:
          li = []
  ```

### コレクションを引数にせずintやstrを受け取る
- `def func(item)`のように辞書を受け取る関数だと、呼び出す側で毎回`item["price"]`のように`price`といった名前を持つ辞書を渡さないといけないので、関数の実装まで見る必要が出てしまう
- `int`や`str`を渡すようにする
### インデックス番号に意味を持たせない
- pythonは基本的にインデックスにアクセスしなくてもイテレータを使って処理できるようになっている
- インデックスに意味を持たせたい場合は、辞書やクラスを使う
- クラスの場合は`@dataclass`といったデコレータがある
  - https://myenigma.hatenablog.com/entry/2020/03/07/171015
- 明示的にインデックス番号が必要な時は`enumerate`を使う
### 不用意に可変長引数を使用しない
- 意図していない引数も受け取れてしまうから
- どのような引数がきても問題ない場合のみ使用する
### コメントには「なぜ」を書く
- 関数の仕様を書くときにはdocstringに書くようにする
### コントローラに処理を書かない
- mainやmvcのコントローラには処理を書かない

<br></br>

## クラス設計
### 辞書ではなくクラスを定義する
- P32,33を直接見た方がいい
- 特定のキーを持つ辞書を期待するならクラスを定義する
- `@dataclass`とか`@property`とかで
### dataclassを使う
- クラスへの引数が多いと冗長な印象があるから
- 型アノテーションも書ける
### インスタンスを作る関数をクラスメソッドにする
- インスタンスを生成して返すという関数のこと

<br></br>

## モジュール設計
### utils.pyのような汎用的な名前を避ける
- どのような時にどのようにすればいいのかわからん
### ビジネスロジックをモジュールに分割する
- モジュールに分割するということは、ファイルごと分割するということ
### モジュールの命名おすすめ
- p43,44

<br></br>

## ユニットテスト
### テストにテスト対象と同等のテストを書かない
- テスト内で入出力を確認する時は、文字列や数値などの値を直接書く

```python
# 実装
import hashlib

def calc_md5(content):
    content = content.strip()
    m = hashlib.md5()
    m.update(content.encode("utf-8"))
    return m.hexdigest()
```

```python
# ダメなテスト
import hashlib
from main import calc_md5

def test_calc_md5():
    actual = calc_md5("This is content")
    m = hashlib.md5()
    m.update(content.encode("utf-8"))
    assert actual == m.hexdigest()
```

```python
# 良いテスト
from main import calc_md5

def test_calc_md5():
    actual = calc_md5("This is content")
    assert actual == b"e61994e96b20e3965b61de16077e18c7"
```

### 1つのテストメソッドでは1つの項目のみを確認する
- 1つのメソッド、関数のテストで複数の入力のテストをしたい場合は、テストクラスを定義して、そのクラス内に複数のテストとしてメソッドでまとめるようにする
- 1つのテストメソッド(関数)に異なる項目のassertを何個も埋め込んではいけない
- 同じ項目のassertなら複数書いても大丈夫
### テストケースは準備、実行、検証に分割
- Arrange Act Assertパターンとして知られている
### 単体テストをする観点から実装の設計を洗練する
- 難しいからあとで
### テストから外部環境への依存を排除しよう
- 単体テストを書くときは外部環境に依存しないように注意する
  - 外部APIへのアクセスとか
- 置き換え方
  - 外部のAPIやサービス(Twitter,SlackなどのAPI)
    - responsesを使ってrequestsをモックする
  - データベースサーバなどのミドルウェア(MySQLやRedisなど)
    - RDBはバックエンドをSQLiteに置き換える
    - Redisはfakeredisに置き換える
  - クラウドサービス(S3やDynamoDB)
    - motoでモックに置き換える
  - 単体テストを実行するPC環境やディレクトリ構成
    - 標準ライブラリのtempfileを使う
    - プロジェクト内の仮想環境venvなど、バージョン管理システムで管理されないファイルに依存しない
### テスト用のデータはテスト後に削除使用
- 自動で削除されないようなデータは`teardown`メソッドなどで削除
- `NamedTemporaryFile`などの使用
### テストユーティリティを活用する
- `factory-boy`や`responses`や`freezegun`など便利なユーティリティがOSSで公開されているからどんどん活用する
### テストケース毎にテストデータを用意する
- よくわからんからあとで
### 必要十分なテストを用意する
- あとで
### テストの実行順序に依存しないテストを書く
- あとで
### 戻り値がリストの関数のテストで要素数をテストする
- 要素数が2つが正解なのに、3つきても正解になってしまう可能性があるから

<br></br>

## 実装の進め方
### 公式ドキュメントを読む
- 他の人のブログ記事とかを読むのではなくて、論理的に小さいところを公式ドキュメントで解決し続けるというやり方の方が結局最短だったりする
### 一度に実装する範囲を小さくしよう、基本的な機能だけ実装してレビューしてもらおう
- 例えば、SNSの投稿機能でも、OAuth認証やトークンをDBに保存するといった処理があるので「トークンをDBに保存」「OAuthのエンドポイントを作成」のようにタスクを分割してレビューしてもらう
### 実装方針を相談しよう
- コードの断片を交えながら議論するとか
### 実装予定箇所にコメントを入れた時点でレビューしてもらう
- まずTODOを書いたものだけをPRで送る
- 実装途中でもTODOコメントを書く
### 必要十分なコードにする



### テストの項目に戻ってかく
